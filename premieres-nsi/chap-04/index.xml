<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Contrôle du flot d’exécution d’un programme, les structures conditionnelles on Accueil</title>
    <link>https://dlatreyte.github.io/premieres-nsi/chap-04/</link>
    <description>Recent content in Contrôle du flot d’exécution d’un programme, les structures conditionnelles on Accueil</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <lastBuildDate>Sun, 29 Aug 2021 00:17:52 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/premieres-nsi/chap-04/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Contrôle du flot d&#39;exécution d&#39;un programme : structures iteratives</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-04/2-structures-iteratives/</link>
      <pubDate>Sun, 29 Aug 2021 00:17:52 +0400</pubDate>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-04/2-structures-iteratives/</guid>
      <description>&lt;p&gt;Ce chapitre reprend l&amp;rsquo;étude de structures de contrôles, c&amp;rsquo;est à dire d&amp;rsquo;instructions qui permettent de modifier le « flot d&amp;rsquo;exécution implicite » d&amp;rsquo;un programme.&lt;/p&gt;&#xA;&lt;p&gt;Après les &lt;strong&gt;structures conditionnelles&lt;/strong&gt; (ou &lt;strong&gt;alternatives&lt;/strong&gt;), les &lt;strong&gt;structures itératives&lt;/strong&gt; (ou &lt;strong&gt;boucles&lt;/strong&gt;) sont introduites.&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Les boucles sont des &lt;em&gt;instructions répétitives&lt;/em&gt;. Comme les tests conditionnels, elles nécessitent la définition de &lt;strong&gt;blocs d’instructions&lt;/strong&gt;.&#xA;Les instructions de ces blocs sont répétées tant qu&amp;rsquo;une &lt;strong&gt;condition d’arrêt&lt;/strong&gt; n&amp;rsquo;est pas vérifiée.&#xA;Chaque passage dans la boucle s&amp;rsquo;appelle une &lt;strong&gt;itération&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Contrôle du flot d&#39;exécution d&#39;un programme : l&#39;alternative</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-04/1-alternative/</link>
      <pubDate>Fri, 27 Aug 2021 16:34:09 +0400</pubDate>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-04/1-alternative/</guid>
      <description>&lt;h2 id=&#34;booléens-et-expressions-booléennes&#34;&gt;Booléens et expressions booléennes&lt;/h2&gt;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  Une &lt;strong&gt;grandeur booléenne&lt;/strong&gt; est une grandeur qui ne peut prendre que deux valeurs : &lt;em&gt;Vrai&lt;/em&gt; ou &lt;em&gt;Faux&lt;/em&gt;, ou &lt;em&gt;0&lt;/em&gt; ou &lt;em&gt;1&lt;/em&gt;, ou …).&#xA;&lt;/div&gt;&#xA;&#xA;&lt;div class=&#34;note normal&#34;&gt;&#xA;  &lt;ul&gt;&#xA;&lt;li&gt;Dans le langage Python, les valeurs booléennes s&amp;rsquo;écrivent &lt;code&gt;True&lt;/code&gt; et &lt;code&gt;False&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;La fonction &lt;code&gt;bool&lt;/code&gt; transforme n&amp;rsquo;importe quel argument en valeur booléenne — tout argument à valeur nulle (entier &lt;code&gt;0&lt;/code&gt;, flottant &lt;code&gt;0.0&lt;/code&gt;, chaîne de caractères &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;, liste vide &lt;code&gt;list()&lt;/code&gt;, etc.) est converti en valeur &lt;code&gt;False&lt;/code&gt;, toute autre valeur pour l&amp;rsquo;argument devient la valeur &lt;code&gt;True&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  &lt;ul&gt;&#xA;&lt;li&gt;Une &lt;strong&gt;expression booléenne&lt;/strong&gt; est une expression dont &lt;em&gt;la valeur est une grandeur booléenne&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Une expression booléenne comporte soit un &lt;strong&gt;opérateur de comparaison&lt;/strong&gt;, soit une &lt;strong&gt;fonction booléenne&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;Opérateur&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;Expression booléenne&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Description&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 &amp;lt; expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne &lt;code&gt;True&lt;/code&gt; si &lt;code&gt;expr1&lt;/code&gt; est strictement inférieure à &lt;code&gt;expr2&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 &amp;gt; expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne &lt;code&gt;True&lt;/code&gt; si &lt;code&gt;expr1&lt;/code&gt; est strictement supérieure à &lt;code&gt;expr2&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 &amp;lt;= expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne &lt;code&gt;True&lt;/code&gt; si &lt;code&gt;expr1&lt;/code&gt; est inférieure ou égale à &lt;code&gt;expr2&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 &amp;gt;= expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne &lt;code&gt;True&lt;/code&gt; si &lt;code&gt;expr1&lt;/code&gt; est supérieure ou égale à &lt;code&gt;expr2&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 == expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne &lt;code&gt;True&lt;/code&gt; si &lt;code&gt;expr1&lt;/code&gt; est égale à &lt;code&gt;expr2&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 != expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne &lt;code&gt;True&lt;/code&gt; si &lt;code&gt;expr1&lt;/code&gt; est différente de &lt;code&gt;expr2&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;not&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;not exprBool&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne le complément logique de &lt;code&gt;exprBool&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 and expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne le résultat d&amp;rsquo;un ET logique&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;expr1 or expr2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;retourne le résultat d&amp;rsquo;un OU logique&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  &lt;ul&gt;&#xA;&lt;li&gt;Un &lt;strong&gt;opérateur&lt;/strong&gt; est une fonction spéciale dont l&amp;rsquo;identificateur s&amp;rsquo;écrit généralement avec des caractères non autorisés pour le nom des fonctions ordinaires (symboles ou ponctuations). &lt;em&gt;Il s&amp;rsquo;agit souvent des équivalents aux opérateurs mathématiques pour le langage de programmation&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Les &lt;strong&gt;opérateurs de comparaison&lt;/strong&gt; &lt;em&gt;retournent un booléen&lt;/em&gt; à partir de nombres (ou de chaînes de caractères).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  Une &lt;strong&gt;fonction booléenne&lt;/strong&gt; est une &lt;em&gt;fonction qui fait correspondre à un ou plusieurs booléens (selon son arité) un booléen&lt;/em&gt;.&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Le comportement d&amp;rsquo;une fonction booléenne ne peut pas être décrit par une courbe&lt;/em&gt;. Cependant, l&amp;rsquo;ensemble des booléens n&amp;rsquo;étant constitué que de deux éléments, on peut établir la &lt;strong&gt;table de vérité&lt;/strong&gt; d&amp;rsquo;une telle fonction, c&amp;rsquo;est à dire &lt;em&gt;l&amp;rsquo;ensemble des valeurs qu&amp;rsquo;elle retourne en fonction des arguments qui lui sont passés&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
