<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Structures hiérarchiques : les arbres on Accueil</title>
    <link>https://dlatreyte.github.io/terminales-nsi/chap-9/</link>
    <description>Recent content in Structures hiérarchiques : les arbres on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Wed, 04 Nov 2020 21:10:53 +0400</lastBuildDate><atom:link href="https://dlatreyte.github.io/terminales-nsi/chap-9/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stratégie gloutonne : Le rendu de monnaie</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/6-rendu-monnaie/</link>
      <pubDate>Sun, 24 Jan 2021 01:51:49 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/6-rendu-monnaie/</guid>
      <description>Un client achète un objet qui coûte 53 euros. Il paye avec un billet de 200 euros. Il faut donc lui rendre 147 euros, par exemple un billet de 100, deux billets de 20, un billet de 5 et une pièce de 2.
Pour minimiser le nombre de pièces (on confond dans ce document les pièces et les billets) à rendre, on peut choisir la stratégie suivante :
 On commence par rendre la pièce de plus grande valeur possible ; On déduit cette valeur de la somme (encore) à rendre ; On recommence, jusqu’à obtenir une somme nulle.</description>
    </item>
    
    <item>
      <title>Problème du sac à dos</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/5-sac-a-dos/</link>
      <pubDate>Thu, 21 Jan 2021 06:41:30 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/5-sac-a-dos/</guid>
      <description>À lire absolument pour en découvrir plus !  Introduction Dans ce document, on s&amp;rsquo;intéresse à une classe de problèmes d&amp;rsquo;optimisation connus sous le nom général de « problème du sac à dos ». On peut définir ce problème de la manière suivante : « durant un cambriolage un voleur possède un sac dont la capacité (en poids par exemple) est limitée. Il se trouve face à un ensemble d&amp;rsquo;objets qu&amp;rsquo;il veut dérober.</description>
    </item>
    
    <item>
      <title>Le codage d&#39;Huffman</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/4-codage-huffman/</link>
      <pubDate>Mon, 16 Nov 2020 16:11:14 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/4-codage-huffman/</guid>
      <description>Cette séance a pour objet l&amp;rsquo;étude d&amp;rsquo;une méthode de compression de données inventée par David Albert Huffman en 1952. Cette méthode permet de réduire la longueur du codage d’un alphabet et repose sur la création d’un arbre binaire.
 Différents types de codages On appelle alphabet l’ensemble des symboles (caractères) composant la donnée de départ à compresser.  Dans la suite, nous utiliserons un alphabet composé seulement des 8 lettres A, B, C, D, E, F, G et H.</description>
    </item>
    
    <item>
      <title>Arbres Binaires Recherche</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/3-arbres-binaires-recherche/</link>
      <pubDate>Tue, 10 Nov 2020 05:04:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/3-arbres-binaires-recherche/</guid>
      <description>Introduction Quelle structure de données permet :
 d&amp;rsquo;organiser les données selon un ordre donné (numérique, lexicographique, etc.) ; d&amp;rsquo;effectuer des recherches le plus efficacement possible ; d&amp;rsquo;accéder à, d&amp;rsquo;insérer ou de supprimer les données le plus efficacement possible.   Tableaux   Propriétés   On peut ordonner des données dans un tableau mais l&amp;rsquo;algorithme de tri le plus rapide est en $O(n ; \log n)$ ; On peut accéder à une donnée en $O(1)$ ; On peut rechercher une valeur efficacement en utilisant la dichotomie : $O(n)$ ; Supprimer ou insérer une valeur n&amp;rsquo;est pas très efficace : $O(n)$.</description>
    </item>
    
    <item>
      <title>Les arbres binaires</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/2-arbres-binaires/</link>
      <pubDate>Thu, 05 Nov 2020 03:38:41 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/2-arbres-binaires/</guid>
      <description>Le corrigé de l&amp;rsquo;activité se trouve ici  Arbres binaires Définition   Un arbre binaire est un arbre de degré 2 (dont les nœuds sont au plus de degré 2).
  Les enfants d’un nœud sont lus de gauche à droite et sont appelés : fils gauche et fils droit.
   Pour simplifier la présentation, on va considérer que chaque nœud possède exactement deux fils mais que ceux-ci peuvent être vides (None par exemple).</description>
    </item>
    
    <item>
      <title>Structures de données abstraites arborescentes : les arbres</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/1-introduction-arbres/</link>
      <pubDate>Thu, 05 Nov 2020 03:37:56 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/1-introduction-arbres/</guid>
      <description>La notion de listes chaînées est parfaite pour structurer un ensemble d&amp;rsquo;élements destinés à être énumérés séquentiellement. Elle permet aussi d&amp;rsquo;implémenter les structures de piles et de files. Elle n&amp;rsquo;est cependant pas adaptée aux accès spécifiques à des positions données dans la séquence, puisqu&amp;rsquo;il faut alors parcourir toutes les cellules depuis le début de la liste jusqu&amp;rsquo;à la position souhaitée (complexité en $O(N)$).
 Document de référence pour ce cours Structures arborescentes Lorsqu&amp;rsquo;on manipule une information présentant une certaine hiérarchie, il est commun de la représenter graphiquement :</description>
    </item>
    
  </channel>
</rss>
