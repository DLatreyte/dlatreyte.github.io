<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Méthode « Diviser pour régner » on Accueil</title>
    <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/</link>
    <description>Recent content in Méthode « Diviser pour régner » on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Sun, 29 Jan 2023 23:13:31 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Somme des $n$ nombres d&#39;un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/7-somme-nombres/</link>
      <pubDate>Sun, 29 Jan 2023 23:13:31 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/7-somme-nombres/</guid>
      <description>L’objectif de ce document est d’écrire et d’implémenter un algorithme s’appuyant sur le raisonnement « Diviser pour régner » qui permet de déterminer la somme des $n$ nombres (entiers) d&amp;rsquo;un tableau.&#xA;Écrire le code de fonction somme1 dont la spécification est : 1 2 3 4 5 6 7 def somme1(tab: List[float]) -&amp;gt; float: &amp;#34;&amp;#34;&amp;#34; Calcul de la somme des nombres éléments de tab. Algorithme : Récursivité enveloppée &amp;#34;&amp;#34;&amp;#34; Penser à écrire un jeu de tests.</description>
    </item>
    <item>
      <title>Diviser pour régner</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/0-diviser-pour-regner/</link>
      <pubDate>Sun, 29 Jan 2023 21:53:04 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/0-diviser-pour-regner/</guid>
      <description>Dans quel cas ? On parvient à découper un problème en sous-problèmes indépendants les uns des autres. On poursuit cette démarche jusqu&amp;rsquo;à aboutir à une situation simple : cas de base. La solution du cas de base est généralement simple à obtenir et permet la construction de la solution du problème. Remarque C&amp;rsquo;est l&amp;rsquo;indépendance des sous-problèmes qui permet la construction de la solution globale directe par recombinaison des solutions intermédiaires.</description>
    </item>
    <item>
      <title>Décomposition d&#39;un problème en sous-problèmes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/0-decomposition-pb/</link>
      <pubDate>Sun, 29 Jan 2023 21:48:22 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/0-decomposition-pb/</guid>
      <description>Principe On décompose le problème en sous-problèmes plus simples. On résout les sous-problèmes. On combine les sous-problèmes de façon à construire la solution du problème initial. Indépendance des sous-problèmes Si les sous-problèmes sont indépendants les uns des autres : « Diviser pour règner ». Si les sous-problèmes dépendent les uns des autres : « Programmation dynamique ». </description>
    </item>
    <item>
      <title>Recherche numérique de zéros de fonctions</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/5-recherche-zero/</link>
      <pubDate>Thu, 03 Feb 2022 21:28:05 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/5-recherche-zero/</guid>
      <description>Dans ce document on introduit une méthode permettant d&amp;rsquo;évaluer numériquement une solution de l&amp;rsquo;équation $f (x) = 0$, avec $f$ une fonction de $\mathbb{R}$ dans $\mathbb{R}$ (lorsque la solution existe, bien sur) : la méthode de dichotomie.&#xA;La méthode de dichotomie est efficace et converge relativement vite. De plus, les conditions de son utilisation sont assez simples : la fonction $f$ doit seulement être continue et changer de signe sur l&amp;rsquo;intervalle choisi ; La méthode de Newton converge étonnement vite !</description>
    </item>
    <item>
      <title>Problème de la sous-séquence de somme maximale</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/4-max-somme-sous-tableau/</link>
      <pubDate>Fri, 28 Jan 2022 06:12:48 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/4-max-somme-sous-tableau/</guid>
      <description>Ce document étudie le problème de la sous-séquence de somme maximale. Ce problème est intéressant parce qu’il existe nombre d’algorithmes pour le résoudre et la complexité (en nombre d’opérations de somme) de ces algorithmes varie considérablement. Seulement deux algorithmes seront abordés, un prochain document présentera l&amp;rsquo;algorithme le plus efficace (cf. programmation dynamique).&#xA;Présentation Étant donné un tableau tab[1..n] d’entiers (positifs et négatifs), déterminer la valeur maximale du sous-tableau tab[g..h] donnant la plus grande somme de tous les sous-tableaux contigus de tab.</description>
    </item>
    <item>
      <title>Recherche des plus grand et petit éléments dans un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/2-minmax/</link>
      <pubDate>Wed, 26 Jan 2022 05:14:44 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/2-minmax/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;écrire et d&amp;rsquo;implémenter un algorithme s&amp;rsquo;appuyant sur le raisonnement « Diviser pour régner » qui permet de déterminer le maximum et le minimum des éléments dans un tableau.&#xA;Générer une liste contenant un million de termes choisis aléatoirement entre un et mille milliards. Réponse 1 2 3 4 from random import randint if __name__ == &amp;#34;__main__&amp;#34;: tab = [randint(1, int(1e12)) for i in range(int(1e6))] Utiliser les fonctions min et max fournies par le langage Python afin d&amp;rsquo;afficher les maximum et minimum dans la liste.</description>
    </item>
    <item>
      <title>Les tours de Hanoï</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/3-tour-hanoi/</link>
      <pubDate>Tue, 24 Nov 2020 04:54:14 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/3-tour-hanoi/</guid>
      <description>Le problème mathématique des tours de Hanoï a été inventé par Édouard Lucas. Paru d&amp;rsquo;abord en fascicule en 1889 , il est publié ensuite dans le tome 3 de ses « Récréations mathématiques », parues à titre posthume en 1892. Il annonce que ce problème est dû à un de ses amis, N. Claus de Siam (anagramme de Lucas d&amp;rsquo;Amiens, Amiens étant sa ville de naissance), prétendument professeur au collège de Li-Sou-Stian (anagramme de Saint Louis, le lycée où Lucas enseignait).</description>
    </item>
    <item>
      <title>Rotation d&#39;une image bitmap d&#39;un quart de tour</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/6-rotation-image/</link>
      <pubDate>Wed, 18 Nov 2020 17:12:52 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/6-rotation-image/</guid>
      <description>L&amp;rsquo;objectif de cette activité est l&amp;rsquo;écriture d&amp;rsquo;une fonction qui effectue la rotation d&amp;rsquo;une image bitmap de 90 degrés en utilisant le principe « Diviser pour régner ».&#xA;On peut manipuler des images en Python à l&amp;rsquo;aide du module PIL (Python Image Library). Une première partie de l&amp;rsquo;activité est consacrée à la prise en main de ce module. Dans un second temps, la fonction de manipulation des bits est développée.&#xA;Images numériques Définition L&amp;rsquo;image matricielle Une image matricielle, ou « carte de points » (de l&amp;rsquo;anglais « bitmap »), est une image constituée d&amp;rsquo;une matrice de points colorés, c&amp;rsquo;est-à-dire, constituée d&amp;rsquo;un tableau, d&amp;rsquo;une grille, où chaque case possède une couleur qui lui est propre et est considérée comme un point.</description>
    </item>
    <item>
      <title>Le tri fusion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/1-tri-fusion/</link>
      <pubDate>Wed, 18 Nov 2020 17:12:24 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/1-tri-fusion/</guid>
      <description>Le tri fusion d&amp;rsquo;un tableau Description du tri Dans cette partie, nous allons essayer de comprendre les principes sur lesquels s&amp;rsquo;appuie ce tri. Son implémentation, pour des tableaux ou des listes chaînées, sera développée dans les prochaines sections.&#xA;Le tri fusion s&amp;rsquo;appuie sur la méthode Diviser pour régner pour trier les $n$ éléments d&amp;rsquo;une séquence $S$ :&#xA;Diviser : Si la séquence $S$ est composée de 0 ou un élément, retourner $S$ immédiatement ; cette séquence est déjà triée.</description>
    </item>
  </channel>
</rss>
