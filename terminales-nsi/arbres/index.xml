<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Structures hiérarchiques : les arbres on Accueil</title>
    <link>https://dlatreyte.github.io/terminales-nsi/arbres/</link>
    <description>Recent content in Structures hiérarchiques : les arbres on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Mon, 16 Nov 2020 16:11:14 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/terminales-nsi/arbres/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Le codage d&#39;Huffman</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/4-codage-huffman/</link>
      <pubDate>Mon, 16 Nov 2020 16:11:14 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/4-codage-huffman/</guid>
      <description>Cette séance a pour objet l&amp;rsquo;étude d&amp;rsquo;une méthode de compression de données inventée par David Albert Huffman en 1952. Cette méthode permet de réduire la longueur du codage d’un alphabet et repose sur la création d’un arbre binaire.&#xA;Différents types de codages On appelle alphabet l’ensemble des symboles (caractères) composant la donnée de départ à compresser. Dans la suite, nous utiliserons un alphabet composé seulement des 8 lettres A, B, C, D, E, F, G et H.</description>
    </item>
    <item>
      <title>Arbres Binaires Recherche</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/3-arbres-binaires-recherche/</link>
      <pubDate>Tue, 10 Nov 2020 05:04:12 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/3-arbres-binaires-recherche/</guid>
      <description>Introduction Quelle structure de données permet :&#xA;d&amp;rsquo;organiser les données selon un ordre donné (numérique, lexicographique, etc.) ; d&amp;rsquo;effectuer des recherches le plus efficacement possible ; d&amp;rsquo;accéder à, d&amp;rsquo;insérer ou de supprimer les données le plus efficacement possible. Tableaux Propriétés On peut ordonner des données dans un tableau mais l&amp;rsquo;algorithme de tri le plus rapide, pour un jeu de données aléatoires, est en $O(n \; \log n)$ ; On peut accéder à une donnée en $O(1)$ ; On peut rechercher une valeur efficacement en utilisant la dichotomie (si le tableau est trié !</description>
    </item>
    <item>
      <title>Les arbres binaires</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/2-arbres-binaires/</link>
      <pubDate>Thu, 05 Nov 2020 03:38:41 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/2-arbres-binaires/</guid>
      <description>Arbres binaires Définition Un arbre binaire est une structure de données abstraite formée d&amp;rsquo;un ensemble de nœuds organisés hiérarchiquement selon la définition par récurrence suivante :&#xA;Un arbre binaire est :&#xA;soit un arbre vide, noté $E$, ne contenant aucun nœud ; soit un nœud, appelé racine, relié à exactement deux arbres binaires $g$ et $d$, respectivement appelés sous-arbres gauche et sous-arbre droit. On note $T(r,g,d)$ l&amp;rsquo;arbre non vide dont la racine $r$ (on peut aussi indiquer l&amp;rsquo;étiquette de cette racine).</description>
    </item>
    <item>
      <title>Structures de données abstraites arborescentes : les arbres</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/1-introduction-arbres/</link>
      <pubDate>Thu, 05 Nov 2020 03:37:56 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/1-introduction-arbres/</guid>
      <description>La notion de listes chaînées est parfaite pour structurer un ensemble d&amp;rsquo;élements destinés à être énumérés séquentiellement. Elle permet aussi d&amp;rsquo;implémenter les structures de piles et de files. Elle n&amp;rsquo;est cependant pas adaptée aux accès spécifiques à des positions données dans la séquence, puisqu&amp;rsquo;il faut alors parcourir toutes les cellules depuis le début de la liste jusqu&amp;rsquo;à la position souhaitée (complexité en $O(N)$).&#xA;Document de référence pour ce cours Structures arborescentes Lorsqu&amp;rsquo;on manipule une information présentant une certaine hiérarchie, il est commun de la représenter graphiquement :</description>
    </item>
  </channel>
</rss>
