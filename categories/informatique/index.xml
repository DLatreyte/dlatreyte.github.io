<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Informatique on Accueil</title>
    <link>https://dlatreyte.github.io/categories/informatique/</link>
    <description>Recent content in Informatique on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Wed, 14 Oct 2020 18:01:18 +0400</lastBuildDate>
    
	<atom:link href="https://dlatreyte.github.io/categories/informatique/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Listes Chaînées</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-7/1-listes-chainees/</link>
      <pubDate>Wed, 14 Oct 2020 18:01:18 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-7/1-listes-chainees/</guid>
      <description>Un corrigé de la section 1 se trouve ici
  Un corrigé des sections suivantes se trouve ici
   Tableaux  Un tableau est une structure de données dans laquelle les éléments, de même type, occupent des positions contiguës en mémoire. Le nombre d&amp;rsquo;éléments qu&amp;rsquo;un tableau peut contenir est déterminé à la création d&amp;rsquo;un tableau.      Type Python Type abstrait Opération Exemple Complexité     N&amp;rsquo;existe pas Tableau Accès à un élément tab[i] $O(1)$     Modification d&amp;rsquo;un élément tab[i] = x $O(1)$     Effacement d&amp;rsquo;un élément retire(tab, i) $O(n)$     Insertion d&amp;rsquo;un élément insere(tab, x, i) $O(n)$     Recherche d&amp;rsquo;un élément est_dans(tab, x) $O(n)$     La structure de données appelée « liste » dans le langage Python est en fait un tableau dynamique.</description>
    </item>
    
    <item>
      <title>Structures de données fournies avec le langage Python</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/1-structures-integrees/</link>
      <pubDate>Tue, 13 Oct 2020 05:25:49 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/1-structures-integrees/</guid>
      <description>Python possède dans la bibliothèque standard un grand nombre de structures de données, programmées de manière efficace.
Pourquoi différentes structures de données ? Les structures de données organisent différemment les données que le programme traite. Le langage Python fournissant le type list, on pourrait se demander pourquoi ne pas systématiquement l&amp;rsquo;utiliser et pourquoi devoir apprendre de nouveaux types.
En fait, la spécialisation des structures de données rend la programmation plus simple (utilisation de l&amp;rsquo;API) et plus efficace (complexité).</description>
    </item>
    
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/2-exercices/</link>
      <pubDate>Tue, 13 Oct 2020 05:08:27 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/2-exercices/</guid>
      <description>Itérer sur les éléments d&amp;rsquo;un dictionnaire Au zoo de Beauval, il y a 5 éléphants d&amp;rsquo;Asie, 17 écureuils d&amp;rsquo;Asie, 2 pandas d&amp;rsquo;Asie, etc. On représente cet inventaire à l&amp;rsquo;aide d&amp;rsquo;un dictionnaire, de façon suivante :
zoo_Beauval={ &amp;#39;éléphant&amp;#39;: (&amp;#39;Asie&amp;#39;, 5), &amp;#39;écureuil&amp;#39;: (&amp;#39;Asie&amp;#39;, 17), &amp;#39;panda&amp;#39;: (&amp;#39;Asie&amp;#39;, 2), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 4) } On représente de la même façon le zoo de La Flèche :
zoo_LaFleche = { &amp;#39;ours&amp;#39;: (&amp;#39;Europe&amp;#39;, 4), &amp;#39;tigre&amp;#39;: (&amp;#39;Asie&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 11), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 3) } On souhaite se doter d&amp;rsquo;une fonction plus_grand_nombre() qui prend un zoo en paramètre et qui renvoie le nom de l&amp;rsquo;animal le plus représenté dans ce zoo.</description>
    </item>
    
    <item>
      <title>Modéliser les notes des élèves</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/3-annale/</link>
      <pubDate>Tue, 13 Oct 2020 05:06:51 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/3-annale/</guid>
      <description>Partie 1 : Modélisation simpliste On modélise les notes d&amp;rsquo;une élève de la faon suivante :
notes_de_lea = [12, 14, 3, 16, 17, 2, 13, 19]  Quel est le type de notes_de_lea ?  un int une liste un tuple un dictionnaire autre chose   Que vaut l&amp;rsquo;expression notes_de_lea[2] ?  3 14 6 5 autre chose   Quelle instruction permet d&amp;rsquo;ajouter une note de 15 à cette structure de données ?</description>
    </item>
    
    <item>
      <title>Tri par insertion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-5/2-tri-insertion/</link>
      <pubDate>Wed, 07 Oct 2020 21:53:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-5/2-tri-insertion/</guid>
      <description>Objectifs  Le tri par insertion a été étudié en classe de 1ère. Dans ce document, après un rappel du cours de 1ère, nous allons implémenter une version récursive de cet algorithme et ensuite utiliser la possibilité que les fonctions en Python ont d&amp;rsquo;accepter des fonctions comme paramètres, afin de rendre plus générale et utile cette fonction de tri.
 Tri du joueur de cartes Le tri par insertion est un tri « naturel » souvent qualifié de « tri du joueur de carte ».</description>
    </item>
    
    <item>
      <title>Programmation Fonctionnelle</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-5/1-programmation-fonctionnelle/</link>
      <pubDate>Tue, 06 Oct 2020 03:49:30 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-5/1-programmation-fonctionnelle/</guid>
      <description>Qu&amp;rsquo;est-ce que la programmation fonctionnelle ? S&amp;rsquo;il n&amp;rsquo;est pas facile de répondre précisément à cette question, on peut essayer de mettre en évidence les idées que le paradigme fonctionnel promeut :
  Les fonctions doivent être des objets de première classe, c&amp;rsquo;est à dire que les fonctions doivent pouvoir être passées comme arguments à une fonction, les fonctions doivent aussi pouvoir être retournées par une fonction.
  Les fonctions doivent (le plus possible) être pures, c&amp;rsquo;est à dire ne générer aucun effet de bord.</description>
    </item>
    
    <item>
      <title>Jeu de la vie</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/5-jeu-vie/</link>
      <pubDate>Sun, 04 Oct 2020 04:35:40 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/5-jeu-vie/</guid>
      <description>Le but de ce sujet est de réaliser en Python une implémentation du jeu de la vie en utilisant la programmation objet.
 Le jeu de la vie a été inventé par le mathématicien britannique John H. Conway (1937-2020). C’est un exemple de ce qu’on appelle un automate cellulaire. Il se déroule sur un tableau rectangulaire $(L \times H)$ de cellules. Une cellule est représentée par ses coordonnées $x$ et $y$ qui vérifient $0 \leqslant x &amp;lt; L$ et $0 \leqslant y &amp;lt; H$.</description>
    </item>
    
    <item>
      <title>Résoudre un problème grâce aux paradigmes objet et fonctionnel</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/4-fonction/</link>
      <pubDate>Thu, 01 Oct 2020 04:21:17 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/4-fonction/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;illustrer une fois encore l&amp;rsquo;intérêt des différents paradigmes de programmation.
Cas d&amp;rsquo;étude : fonction avec paramètres On considère l&amp;rsquo;équation qui traduit le mouvement d&amp;rsquo;une balle lancée verticalement vers le haut avec une vitesse $\vec{v}_0$ depuis l&amp;rsquo;origine des altitudes telle que l&amp;rsquo;écrit un physicien : $$y(t) = -\dfrac{1}{2}g\, t^2 + v_0\, t$$ Ce physicien a donc tendance à considérer que $y$ est une fonction de la variable $t$ et que cette fonction dépend des paramètres $v_0$ et $g$.</description>
    </item>
    
    <item>
      <title>Méthodes spéciales</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/3-exercices/</link>
      <pubDate>Tue, 29 Sep 2020 09:51:52 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/3-exercices/</guid>
      <description>Définit une classe nommée Fraction pour représenter les nombres rationnels. Cette classe doit posséder deux attributs num et denom, de type entier, qui représentent respectivement le numérateur et le dénominateur du nombre rationnel.
On demande que le dénominateur soit un entier positif.
Un corrigé de cette activité se trouve à cette adresse : https://repl.it/@dlatreyte/fraction   Écrire le constructeur de cette classe. Une exception de type ValueError doit être levée si le dénominateur n&amp;rsquo;est pas un nombre entier positif.</description>
    </item>
    
    <item>
      <title>Simulation du fonctionnement d&#39;une banque</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/2-banque/</link>
      <pubDate>Sat, 26 Sep 2020 20:06:58 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/2-banque/</guid>
      <description>L&amp;rsquo;objectif de ce document est de simuler (sommairement bien sûr) le fonctionnement d&amp;rsquo;une banque. Le programme doit permettre :
 La création d&amp;rsquo;une banque ; La création de comptes bancaires ; La création de personnes propriétaires de ces comptes bancaires.  Une correction se trouve à cette adresse : https://repl.it/@dlatreyte/banque Classe Personne Dans un module nommé personne, créer la classe Personne dont la spécification est la suivante :
class Personne(): &amp;#34;&amp;#34;&amp;#34; Modélisation d&amp;#39;une personne.</description>
    </item>
    
    <item>
      <title>Programmation Objet</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/1-programmation-objet/</link>
      <pubDate>Wed, 23 Sep 2020 21:07:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/1-programmation-objet/</guid>
      <description>Programmation orientée objet L&amp;rsquo;un des objectifs principaux de la notion d&amp;rsquo;objet est d&amp;rsquo;organiser des programmes complexes grâce aux notions :
 d&amp;rsquo;encapsulation ; d&amp;rsquo;abstraction ; d&amp;rsquo;héritage ; de polymorphisme ;  Remarque : Seules les deux premières notions apparaissent dans le programme de NSI.
Encapsulation Le principe de l&amp;rsquo;encapsulation est de regrouper dans le même objet, les données (attributs) et les traitements (méthodes) qui lui sont spécifiques. Ainsi un objet est défini par ses attributs et ses méthodes.</description>
    </item>
    
    <item>
      <title>Fourniture et utilisation d&#39;une API</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/4-api/</link>
      <pubDate>Tue, 22 Sep 2020 05:15:58 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/4-api/</guid>
      <description>API Une API (en anglais « Application programming interface ») est une interface de programmation d&amp;rsquo;application. Elle est destinée à être utilisée par des programmes. Le principe de ce type d&amp;rsquo;interface est le même que celui des UI (« User Interface ») ou des GUI (« Graphical User Interface ») destinées elles à un utilisateur humain.
Composée de constantes, de fonctions, de classes, elle sert de lien entre un programme et les programmes qui vont l&amp;rsquo;utiliser.</description>
    </item>
    
    <item>
      <title>Paradigmes de programmation</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-3/1-paradigmes-programmation/</link>
      <pubDate>Mon, 21 Sep 2020 20:58:45 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-3/1-paradigmes-programmation/</guid>
      <description>Langages de programmation Un langage de programmation a besoin :
 des règles de grammaire qui définissent la syntaxe des expressions ; d&amp;rsquo;une sémantique qui définit le sens des expressions.   Un langage peut être :
 interprété : un interpréteur lit et analyse le code séquentiellement, le traduit en langage machine et lance son exécution. compilé : un compilateur lit et analyse le code puis le traduit en langage machine.</description>
    </item>
    
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</link>
      <pubDate>Sun, 20 Sep 2020 05:12:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</guid>
      <description>Enquêter sur une erreur dans un calcul de $\pi$ La somme des inverses des carrés des nombres entiers converge vers $\dfrac{\pi^2}{6}$.
$$\sum_{k=1}^{\infty} \dfrac{1}{k^2} = \dfrac{\pi^2}{6}$$
On utilise cette formule pour trouver une approximation de $\pi$. 1 2 3 4 5 6 7 8 9 10 11 12 13  import math def terme(k: int) -&amp;gt; float: return 1 / (k**2) def approxpi(n: int) -&amp;gt; float: s = 0 # utilise les termes jusqu’à 1/n**2 inclus for k in range(n): s = s + terme(k) return math.</description>
    </item>
    
    <item>
      <title>Modules et exceptions</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</link>
      <pubDate>Tue, 15 Sep 2020 05:06:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</guid>
      <description>Ce chapitre se concentre sur les modules de Python et sur les modalités d&amp;rsquo;importation des données des modules dans l&amp;rsquo;environnement de travail.
L&amp;rsquo;objectif de ce document est de souligner l&amp;rsquo;importance d&amp;rsquo;un code modulaire, c&amp;rsquo;est à dire d&amp;rsquo;un code qui :
 puisse être utilisé dans plusieurs programmes ; puisse être documenté précisément ; soit suffisamment compact pour être étudié avec soin et en particulier testé.   Qu&amp;rsquo;est-ce qu&amp;rsquo;un module ?</description>
    </item>
    
    <item>
      <title>Capitalisation d&#39;une valeur</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</link>
      <pubDate>Tue, 15 Sep 2020 05:05:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</guid>
      <description>Cette séance a pour objectif de vous familiariser avec la création et la manipulation de modules.
Comme il est maintenant de tradition vous diviserez le code de votre programme principal en trois parties:
 Importation des modules ; Définitions des fonctions ; Partie principale (lieu d&amp;rsquo;appel des fonctions).  Vous documenterez aussi systématiquement vos fonctions (une aide sera fournie dans les questions relatives à la définition de chacune de ces fonctions).</description>
    </item>
    
    <item>
      <title>Introduction à l&#39;algorithmique, recherche d&#39;un élément dans un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</link>
      <pubDate>Sat, 12 Sep 2020 17:46:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</guid>
      <description>Algorithmique Introduction Un algorithme est une suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser afin de résoudre un problème.  En informatique, pour qu&amp;rsquo;un algorithme puisse être implémenté, il est nécessaire de s&amp;rsquo;assurer que la « suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser » s&amp;rsquo;effectue en une durée finie .
Lorsqu&amp;rsquo;on élabore ou étudie un algorithme, il est donc nécessaire de vérifier :
 Sa finitude : Il doit se terminer en un temps fini.</description>
    </item>
    
    <item>
      <title>Recherche d&#39;un élément dans un tableau&amp;nbsp;: algorithmes itératifs et récursifs</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</link>
      <pubDate>Wed, 09 Sep 2020 21:33:15 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</guid>
      <description>Recherche d&amp;rsquo;un élément dans un tableau La recherche d&amp;rsquo;éléments dans un tableau a déjà été évoquée en classe de première. Les deux algorithmes mis en œuvre à cette occasion, la recherche linéaire et la recherche dichotomique, utilisaient des boucles.
L&amp;rsquo;objectif de cette séance est de rapidement revoir ces algorithmes et de mettre en œuvres des algorithmes récursifs de même complexité. Quatre algorithmes de recherche vont donc être implémentés :
 La recherche linéaire itérative ; La recherche linéaire récursive ; La recherche dichotomique itérative ; La recherche dichotomique récursive.</description>
    </item>
    
    <item>
      <title>La récursivité appliquée aux chaînes de caractères et aux listes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</link>
      <pubDate>Tue, 08 Sep 2020 04:53:31 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</guid>
      <description>Penser à écrire, pour chacune des fonctions ci-dessous, sa spécification ainsi qu&amp;rsquo;un jeu de tests.
Recherche dans une chaîne de caractères Écrire une fonction récursive nommée est_dans, qui, à partir d&amp;rsquo;un caractère e et d&amp;rsquo;une chaîne de caractères c, détermine si ce caractère appartient à la chaîne.
Tester cette fonction.
Remarque : la fonction est_dans est un prédicat.
    Solution  def est_dans(e: str, c: str) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34; Détermine si le caractère e est dans la chaîne c.</description>
    </item>
    
    <item>
      <title>Récursivité sur les entiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</link>
      <pubDate>Sat, 05 Sep 2020 18:34:00 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</guid>
      <description>La récurrence est un raisonnement mathématique courant et parmi les plus puissants pour démontrer des théorèmes ou construire des objets. Par exemple, on l&amp;rsquo;utilise dans un cours de mathématique de lycée pour montrer que :
 Pour tout entier $n \geqslant 0$, on a : $1 + 2 + 3 + \ldots + n = \dfrac{n(n+1)}{2}$ ; Un entier naturel n&amp;rsquo;est autre que 0 ou le successeur d&amp;rsquo;un entier naturel (0 est 0, 1 est le successeur de 0, 2 est le successeur de 1, &amp;hellip;).</description>
    </item>
    
    <item>
      <title>Problème du sac à dos</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-02/</link>
      <pubDate>Sun, 23 Aug 2020 23:27:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-02/</guid>
      <description>Au programme Algorithmique    Contenus Capacités attendues Commentaires     Algorithmes gloutons Résoudre un problème grâce à un algorithme glouton. Exemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale.    </description>
    </item>
    
    <item>
      <title>Algorithmes gloutons, problème du rendu de monnaie</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-01/</link>
      <pubDate>Sun, 23 Aug 2020 23:00:09 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-01/</guid>
      <description>Au programme Algorithmique    Contenus Capacités attendues Commentaires     Algorithmes gloutons Résoudre un problème grâce à un algorithme glouton. Exemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale.    Introduction Les algorithmes gloutons forment une catégorie d&amp;rsquo;algorithmes permettant de parvenir à une solution pour un problème d&amp;rsquo;optimisation qui vise à maximiser/minimiser une quantité (plus court chemin (GPS), plus petite durée d&amp;rsquo;exécution, meilleure organisation d&amp;rsquo;un emploi du temps, etc.</description>
    </item>
    
    <item>
      <title>Les différentes erreurs lorsqu&#39;on calcule à l&#39;aide d&#39;un ordinateur</title>
      <link>https://dlatreyte.github.io/superieur/calcul_numerique_et_erreurs/</link>
      <pubDate>Fri, 21 Aug 2020 14:08:45 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/superieur/calcul_numerique_et_erreurs/</guid>
      <description>Dans ce document, on s&amp;rsquo;intéresse au différentes erreurs qui interviennent lorsqu&amp;rsquo;on effectue des calculs à l&amp;rsquo;aide d&amp;rsquo;un ordinateur. On prend pour exemple le calcul numérique de la dérivée d&amp;rsquo;une fonction, qu&amp;rsquo;elle soit définie analytiquement ou numériquement (par une table de valeurs).
Dérivation d&amp;rsquo;une fonction analytique &amp;mdash; idée simple Introduction Le nombre dérivé $f&amp;rsquo;(x)$ en un point $x \in \mathbb{R}$, d&amp;rsquo;une fonction1 : $$ \begin{array}{l|rcl} f: &amp;amp; \mathbb{R} &amp;amp; \longrightarrow &amp;amp; \mathbb{R} \cr &amp;amp; x &amp;amp; \longmapsto &amp;amp; f(x) \end{array} $$</description>
    </item>
    
    <item>
      <title>Premiers pas en programmation... et en Python</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</link>
      <pubDate>Sat, 14 Sep 2019 21:37:45 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</guid>
      <description>On appelle informatique le traitement automatisé des informations par un ordinateur. Cette discipline s&amp;rsquo;appuie sur la programmation, activité qui consiste à apprendre à un ordinateur à effectuer des tâches qu&amp;rsquo;il n&amp;rsquo;est pas capable d&amp;rsquo;exécuter à sa conception. L&amp;rsquo;écriture d&amp;rsquo;un programme nécessite l&amp;rsquo;utilisation d&amp;rsquo;un langage de programmation. Dans ce cours nous utiliserons Python.
Au programme Langages et programmation    Contenus Capacités attendues Commentaires     Constructions élémentaires Mettre en évidence un corpus de constructions élémentaires.</description>
    </item>
    
    <item>
      <title>Éléments d&#39;histoire et d&#39;architecture des ordinateurs</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-01/chap-01/</link>
      <pubDate>Tue, 10 Sep 2019 23:50:18 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-01/chap-01/</guid>
      <description>Au programme Histoire de l’informatique    Contenus Capacités attendues Commentaires     Événements clés de l’histoire de l’informatique Situer dans le temps les principaux événements de l’histoire de l’informatique et leurs protagonistes. Ces repères historiques seront construits au fur et à mesure de la présentation des concepts et techniques.    Langages et programmation    Contenus Capacités attendues Commentaires     Diversité et unité des langages de programmation Repérer, dans un nouveau langage de programmation, les traits communs et les traits particuliers à ce langage.</description>
    </item>
    
  </channel>
</rss>