<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Informatique on Accueil</title>
    <link>https://dlatreyte.github.io/categories/informatique/</link>
    <description>Recent content in Informatique on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Fri, 24 Nov 2023 12:59:57 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/categories/informatique/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tri par insertion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/tris/2-tri-par-insertion/</link>
      <pubDate>Fri, 24 Nov 2023 12:59:57 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/tris/2-tri-par-insertion/</guid>
      <description>Tri du joueur de cartes Le tri par insertion est un tri « naturel » souvent qualifié de « tri du joueur de carte ».&#xA;Comment un joueur de carte trie-t-il ses cartes ?&#xA;Au début, la main gauche du joueur est vide et ses cartes sont posées sur la table. Le joueur prend alors sur la table les cartes, une par une avec sa main droite, pour les placer dans sa main gauche.</description>
    </item>
    <item>
      <title>Tri par sélection</title>
      <link>https://dlatreyte.github.io/terminales-nsi/tris/1-tri-par-selection/</link>
      <pubDate>Fri, 24 Nov 2023 12:59:47 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/tris/1-tri-par-selection/</guid>
      <description>La recherche d&amp;rsquo;un élément dans un tableau est beaucoup plus efficace si ce tableau est ordonné. À vrai dire, ce n&amp;rsquo;est pas en cours d&amp;rsquo;informatique que vous avez découvert ceci : dans toutes les bibliothèques les livres sont classés de façon à rendre leur recherche plus rapide !&#xA;Le tri des tableaux/listes permet de trouver rapidement les objets recherchés et facilite la recherche des valeurs extrêmes. La question que se propose d&amp;rsquo;aborder ce document est donc : « comment classer les éléments d&amp;rsquo;un tableau selon une relation d&amp;rsquo;ordre donnée ?</description>
    </item>
    <item>
      <title>Algorithmes de tri</title>
      <link>https://dlatreyte.github.io/terminales-nsi/tris/</link>
      <pubDate>Fri, 24 Nov 2023 12:59:28 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/tris/</guid>
      <description>Au programme de la classe de première Contenus Capacités attendues Commentaires Tris par insertion, par sélection - Écrire un algorithme de tri.&#xA;- Décrire un invariant de boucle qui prouve la correction des tris par insertion, par sélection. - La terminaison de ces algorithmes est à justifier.&#xA;- On montre que leur coût est quadratique dans le pire cas. Documents Doc. Tri par sélection&#xA;Doc. Tri par insertion</description>
    </item>
    <item>
      <title>Réalisation d&#39;une classe Liste Chainee</title>
      <link>https://dlatreyte.github.io/terminales-nsi/listes-chainees/3-classe-liste-chainee/</link>
      <pubDate>Mon, 20 Nov 2023 15:50:34 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/listes-chainees/3-classe-liste-chainee/</guid>
      <description>Par transformation des fonctions du document 1 dans ce chapitre en méthodes, écrire le code de la classe Liste qui définit le type abstrait « Liste chaînée ».&#xA;Réponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 from __future__ import annotations class Maillon: &amp;#34;&amp;#34;&amp;#34; Un maillon de la liste.</description>
    </item>
    <item>
      <title>Implémentation du type abstrait Liste Chaînée à l&#39;aide de listes Python</title>
      <link>https://dlatreyte.github.io/terminales-nsi/listes-chainees/2-listes-chainees-liste/</link>
      <pubDate>Mon, 20 Nov 2023 15:50:09 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/listes-chainees/2-listes-chainees-liste/</guid>
      <description>Reprendre toutes les fonctions des sections 2 et 3 du document 1 de ce chapitre, en implémentant cette fois le type abstrait « Liste chaînée » à l&amp;rsquo;aide de tuples (à la place de la classe).&#xA;Réponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def est_dans(tab: list[int], val: int) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34; Recherche la présence de val dans tab.</description>
    </item>
    <item>
      <title>Algorithmes gloutons</title>
      <link>https://dlatreyte.github.io/terminales-nsi/gloutons/</link>
      <pubDate>Mon, 20 Nov 2023 15:18:34 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/gloutons/</guid>
      <description>Au programme de la classe de première Contenus Capacités attendues Commentaires Algorithmes gloutons Résoudre un problème grâce à un algorithme glouton. Exemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale. Documents Doc. Le rendu de monnaie&#xA;Doc. Le problème du sac à dos</description>
    </item>
    <item>
      <title>Héron d&#39;Alexandrie</title>
      <link>https://dlatreyte.github.io/terminales-nsi/revisions/heron_alexandrie/</link>
      <pubDate>Sun, 05 Sep 2021 04:24:09 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/revisions/heron_alexandrie/</guid>
      <description>Héron d&amp;rsquo;Alexandrie est un ingénieur, un mécanicien et un mathématicien grec du premier siècle après J.-C.&#xA;On ne sait pas grand chose de la vie d&amp;rsquo;Héron, si ce n&amp;rsquo;est qu&amp;rsquo;il était originaire d&amp;rsquo;Alexandrie ; les historiens se sont même longtemps divisés sur l&amp;rsquo;époque où il a vécu. Leurs estimations allaient du 1er siècle avant J.-C. au 3ème siècle de notre ère. Aujourd&amp;rsquo;hui, la querelle est éteinte : il est clairement établi que Héron est postérieur à Vitruve mort en $- 20$, et contemporain de Pline l&amp;rsquo;Ancien (23 &amp;ndash; 79), en étant actif autour de l&amp;rsquo;an 62.</description>
    </item>
    <item>
      <title>Le modèle Entités/Associations</title>
      <link>https://dlatreyte.github.io/terminales-nsi/bases-donnees/2-entite-association/</link>
      <pubDate>Tue, 02 Feb 2021 05:04:55 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/bases-donnees/2-entite-association/</guid>
      <description>Le modèle Entités/Associations en tant que tel n&amp;rsquo;est pas au programme. Par contre il me semble utile afin de vous faire comprendre comment on modèle le réel et on parvient au final à un schéma relationnel.&#xA;L&amp;rsquo;objectif de ce chapitre n&amp;rsquo;est donc pas la conception de schémas E/A mais plutôt leur compréhension et leur interprétation.&#xA;Ce chapitre présente la première étape du processus de modélisation du monde réel. On commence par recueillir les informations à intégrer dans la base de donnée puis on les transcrit sous une forme qui nous permettra, dans le prochain chapitre, à passer au modèle relationnel (choix de la structure de la base, clés, .</description>
    </item>
    <item>
      <title>Du schéma entités/associations au schéma relationnel</title>
      <link>https://dlatreyte.github.io/terminales-nsi/bases-donnees/3-vers-modele-relationnel/</link>
      <pubDate>Tue, 02 Feb 2021 04:31:48 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/bases-donnees/3-vers-modele-relationnel/</guid>
      <description>Concepts relationnels Modèle relationnel Le modèle relationnel tire son nom de la notion de relation mathématique entre les éléments. Chacun de ces éléments peut prendre des valeurs dans un ensemble défini.&#xA;Par exemple, les appareils électroménagers d&amp;rsquo;une cuisine peuvent être contenus dans l&amp;rsquo;ensemble des valeurs suivantes : {Réfrigérateur, Cuisinière, Hotte, Robot, Lave-vaisselle}. On peut, par ailleurs, aussi considérer l&amp;rsquo;ensemble des couleurs que peuvent prendre ces appareils : {Rouge, Vert, Bleu, Jaune, Blanc, Noir, Rose}.</description>
    </item>
    <item>
      <title>Introduction aux bases de données</title>
      <link>https://dlatreyte.github.io/terminales-nsi/bases-donnees/1-introduction-bases-de-donnees/</link>
      <pubDate>Sun, 31 Jan 2021 04:39:04 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/bases-donnees/1-introduction-bases-de-donnees/</guid>
      <description>Qu&amp;rsquo;est-ce qu&amp;rsquo;une base de données ? Le nombre d&amp;rsquo;informations disponibles et les moyen de les diffuser sont en constante progression. La croissance du Web a encore accru ce développement en fournissant l&amp;rsquo;accès à des bases de données gigantesques et très diverses par l&amp;rsquo;intermédiaire d&amp;rsquo;une interface commune (Amazon, Google, Facebook, ...).&#xA;Notion de base de données Tout le monde a une idée naturelle de ce que peut être une base de donnée, nous stockons, sur nos disques durs, non seulement des fichiers musicaux, mais aussi des informations relatives à ces derniers : noms des artistes, des albums, dates d&amp;rsquo;enregistrements, noms et numéros des morceaux, parfois noms des musiciens, .</description>
    </item>
    <item>
      <title>Dessin de figures fractales</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/5-fractales/</link>
      <pubDate>Tue, 26 Jan 2021 06:16:46 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/5-fractales/</guid>
      <description>Le mot fractale vient du latin fractus qui signifie brisé. En effet, une figure fractale est un objet géométrique infiniment morcelé des détails sont observables à une échelle arbitrairement choisie.&#xA;En zoomant sur une partie de la figure, on peut retrouver toute la figure, on dit qu&amp;rsquo;elle est auto similaire.&#xA;http://www.maths-et-tiques.fr/index.php/detentes/les-fractales&#xA;http://fr.wikipedia.org/wiki/Fractalehttp://fr.wikipedia.org/wiki/Fractale&#xA;Introduction Dans le code suivant (qu&amp;rsquo;il faudra étudier et exécuter) :&#xA;Quel est le cas de base de l&amp;rsquo;algorithme récursif ?</description>
    </item>
    <item>
      <title>Le problème du sac à dos</title>
      <link>https://dlatreyte.github.io/terminales-nsi/gloutons/2-sac-a-dos/</link>
      <pubDate>Thu, 21 Jan 2021 06:41:30 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/gloutons/2-sac-a-dos/</guid>
      <description>À lire absolument pour en découvrir plus ! Introduction Dans ce document, on s&#39;intéresse à une classe de problèmes d&#39;optimisation connus sous le nom général de « problème du sac à dos ». On peut définir ce problème de la manière suivante : *« durant un cambriolage un voleur possède un sac dont la capacité (en poids par exemple) est limitée. Il se trouve face à un ensemble d&#39;objets qu&#39;il veut dérober.</description>
    </item>
    <item>
      <title>Bases de données</title>
      <link>https://dlatreyte.github.io/terminales-nsi/bases-donnees/</link>
      <pubDate>Mon, 18 Jan 2021 17:54:59 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/bases-donnees/</guid>
      <description>Le développement des traitements informatiques nécessite la manipulation de données de plus en plus nombreuses. Leur organisation et leur stockage constituent un enjeu essentiel de performance. Le recours aux bases de données relationnelles est aujourd’hui une solution très répandue. Ces bases de données permettent d’organiser, de stocker, de mettre à jour et d’interroger des données structurées volumineuses utilisées simultanément par différents programmes ou différents utilisateurs. Cela est impossible avec les représentations tabulaires étudiées en classe de première.</description>
    </item>
    <item>
      <title>Exercices de programmation objet</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-objet/6-exercices/</link>
      <pubDate>Wed, 13 Jan 2021 19:12:34 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-objet/6-exercices/</guid>
      <description>Chaque méthode définie devra être accompagnée de sa spécification. Manipulation de points On considère la classe nommée Point ayant les attributs suivants :&#xA;__abs : attribut privé de type float pour représenter l&amp;rsquo;abscisse du point ; __ord : attribut privé de type float pour représenter l&amp;rsquo;ordonnée du point. Définir la class Point et le constructeur __init__ permettant d&amp;rsquo;initialiser les deux attributs. L&amp;rsquo;encapsulation est un concept fondamental de la conception objet.</description>
    </item>
    <item>
      <title>Gestion des processus et des ressources</title>
      <link>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/3-processus/</link>
      <pubDate>Sun, 10 Jan 2021 05:10:07 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/3-processus/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;essayer de faire comprendre les idées mises en œuvre lors de l&amp;rsquo;écriture des système d&amp;rsquo;exploitation afin qu&amp;rsquo;un nombre de programmes plus important que le nombre de processeurs puisse fonctionner « simultanément ».&#xA;L&amp;rsquo;ordonnanceur Rappel sur l&amp;rsquo;exécution d&amp;rsquo;un programme Un programme est un fichier contenant une suite d&amp;rsquo;instructions écrites en langage machine. C&amp;rsquo;est une suite d&amp;rsquo;octets que le processeur est capable de décoder et d&amp;rsquo;exécuter.</description>
    </item>
    <item>
      <title>Système d&#39;exploitation : Principes généraux</title>
      <link>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/1-os-principes-generaux/</link>
      <pubDate>Wed, 06 Jan 2021 16:24:21 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/1-os-principes-generaux/</guid>
      <description>Introduction À l&amp;rsquo;aide d&amp;rsquo;un éditeur de texte, écrire le programme Python suivant : 1 2 3 4 5 6 from os.path import getsize from tkinter.filedialog import askopenfilename fichier = askopenfilename() if fichier: print(&amp;#34;Fichier a pour taille {} octets&amp;#34;.format(str(getsize(fichier)))) Exécuter le programme.&#xA;À l&amp;rsquo;aide de la fonction help préciser le rôle des fonctions getsize du module os et askopenfilename du module tkinter.filedialog.&#xA;Réponse askopenfilename du module tkinter.filedialog crée une boite de dialogue permettant de sélectionner un fichier.</description>
    </item>
    <item>
      <title>Le routage entre réseaux IP</title>
      <link>https://dlatreyte.github.io/terminales-nsi/reseaux/5-routage/</link>
      <pubDate>Sat, 02 Jan 2021 15:51:33 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/reseaux/5-routage/</guid>
      <description>Routeurs et objectif du routage ? La responsabilité d’un protocole de routage est de fournir l’information nécessaire pour effectuer un routage, c’est-à-dire la détermination d’un chemin entre une machine émettrice et une machine réceptrice, toutes deux identifiées par leur adresse IP sur des sous-réseaux différents. Un routeur est un ordinateur possédant au moins deux interfaces réseaux situées sur des sous-réseaux IP différents. Il faut être capable de distinguer une carte réseau d&amp;rsquo;une interface réseau.</description>
    </item>
    <item>
      <title>Système de fichiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/2-navigation-systeme-fichiers/</link>
      <pubDate>Wed, 09 Dec 2020 16:15:48 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/2-navigation-systeme-fichiers/</guid>
      <description>Linux est un logiciel libre Un logiciel est dit libre si son code est couvert par une licence autorisant :&#xA;l&amp;rsquo;utilisation du logiciel ; l&amp;rsquo;accès public au code source ; la modification et la redistribution publique de ces modifications. Introduction Il est possible de commander les systèmes d&amp;rsquo;exploitation de la famille UniX et leurs dérivés (tels OS X et Linux) grâce à un logiciel appelé shell, en ligne de commandes.</description>
    </item>
    <item>
      <title>Les systèmes d&#39;exploitation</title>
      <link>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/</link>
      <pubDate>Wed, 09 Dec 2020 10:12:03 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/systemes-exploitation/</guid>
      <description>Toute machine est dotée d’un système d’exploitation qui a pour fonction de charger les programmes depuis la mémoire de masse et de lancer leur exécution en leur créant des processus, de gérer l’ensemble des ressources, de traiter les interruptions ainsi que les entrées-sorties et enfin d’assurer la sécurité globale du système.&#xA;Au programme de la classe de première Contenus Capacités attendues Commentaire Systèmes d’exploitation - Identifier les fonctions d’un système d’exploitation.</description>
    </item>
    <item>
      <title>Simulation de réseaux</title>
      <link>https://dlatreyte.github.io/terminales-nsi/reseaux/4-simulation-reseau/</link>
      <pubDate>Sun, 06 Dec 2020 04:35:41 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/reseaux/4-simulation-reseau/</guid>
      <description>L&amp;rsquo;objectif de cette séance est de mettre en pratique les concepts rappelés lors des séances précédentes et d&amp;rsquo;introduire la notion de routage.&#xA;Télécharger le logiciel Filius&#xA;Attention : Choisir la langue lors de la première ouverture du logiciel. En cas d’erreur, supprimer le dossier .filius contenant les paramètres de langues se trouvant dans C:\Users\nom d’utilisateur sur le réseau\AppData\Local\.filius (sous windows).&#xA;Construction d&amp;rsquo;un réseau local En mode conception, créer le réseau local suivant : Configurer chaque ordinateur : Mode conception $\longrightarrow$ Clic droit sur l&amp;rsquo;ordinateur $\longrightarrow$ Configurer.</description>
    </item>
    <item>
      <title>Analyse du protocole de transport TCP</title>
      <link>https://dlatreyte.github.io/terminales-nsi/reseaux/3-analyse-tcp/</link>
      <pubDate>Sun, 29 Nov 2020 05:59:52 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/reseaux/3-analyse-tcp/</guid>
      <description>Cette séance nécessite l&amp;rsquo;utilisation du logiciel libre Wireshark. Des versions pour Windows (il existe même une version portable qui n&amp;rsquo;a pas besoin d&amp;rsquo;être installée), OS X et Linux sont téléchargeables à cette adresse : https://www.wireshark.org Fichiers pour utilisation de Wireshark Rechercher pour quelles actions les protocoles http, pop3, ftp, telnet, ssh et dns sont utilisés.&#xA;Ces protocoles s&amp;rsquo;appuient-ils sur le protocole TCP ou le protocole UDP au niveau de la couche transport du modèle OSI.</description>
    </item>
    <item>
      <title>Adressage IPv4</title>
      <link>https://dlatreyte.github.io/terminales-nsi/reseaux/2-ip/</link>
      <pubDate>Thu, 26 Nov 2020 06:16:49 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/reseaux/2-ip/</guid>
      <description>L&amp;rsquo;adresse IPv4 d&amp;rsquo;un réseau est 192.168.56.0/24. Combien de bits sont-ils dédiés à la partie réseau ? Combien de machines peut-on incorporer à ce réseau ? Réponse 24 bits sont réservés au réseau dans l&amp;rsquo;adresse. Une adresse IPv4 étant composée de 32 bits, il reste 8 bits pour l&amp;rsquo;adressage des machines dans ce réseau. Avec ces 8 bits on peut créer $2^8 = 256$ adresses différentes, pour $2^8 - 2 = 254$ ordinateurs.</description>
    </item>
    <item>
      <title>Modélisation des réseaux</title>
      <link>https://dlatreyte.github.io/terminales-nsi/reseaux/1-modelisation-reseaux/</link>
      <pubDate>Thu, 26 Nov 2020 06:13:06 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/reseaux/1-modelisation-reseaux/</guid>
      <description>Vocabulaire Réseau : ensemble d’équipements interconnectés (liaisons mais aussi protocoles).&#xA;Un internet : réseau informatique dont le protocole de routage/adressage est IP (Internet Protocol).&#xA;L’Internet : réseau des réseaux —plus grand réseau internet&#xA;Tous les réseaux internet ne font pas partie de l’Internet. Le WEB (World Wide Web) est seulement une composante de l’Internet. Structure d&amp;rsquo;un internet Pour transmettre des données d’un équipement vers un autre, il faut envoyer un signal sur un support de communication.</description>
    </item>
    <item>
      <title>Le codage d&#39;Huffman</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/4-codage-huffman/</link>
      <pubDate>Mon, 16 Nov 2020 16:11:14 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/4-codage-huffman/</guid>
      <description>Cette séance a pour objet l&amp;rsquo;étude d&amp;rsquo;une méthode de compression de données inventée par David Albert Huffman en 1952. Cette méthode permet de réduire la longueur du codage d’un alphabet et repose sur la création d’un arbre binaire.&#xA;Différents types de codages On appelle alphabet l’ensemble des symboles (caractères) composant la donnée de départ à compresser. Dans la suite, nous utiliserons un alphabet composé seulement des 8 lettres A, B, C, D, E, F, G et H.</description>
    </item>
    <item>
      <title>Arbres Binaires Recherche</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/3-arbres-binaires-recherche/</link>
      <pubDate>Tue, 10 Nov 2020 05:04:12 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/3-arbres-binaires-recherche/</guid>
      <description>Introduction Quelle structure de données permet :&#xA;d&amp;rsquo;organiser les données selon un ordre donné (numérique, lexicographique, etc.) ; d&amp;rsquo;effectuer des recherches le plus efficacement possible ; d&amp;rsquo;accéder à, d&amp;rsquo;insérer ou de supprimer les données le plus efficacement possible. Tableaux Propriétés On peut ordonner des données dans un tableau mais l&amp;rsquo;algorithme de tri le plus rapide, pour un jeu de données aléatoires, est en $O(n \; \log n)$ ; On peut accéder à une donnée en $O(1)$ ; On peut rechercher une valeur efficacement en utilisant la dichotomie (si le tableau est trié !</description>
    </item>
    <item>
      <title>Les arbres binaires</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/2-arbres-binaires/</link>
      <pubDate>Thu, 05 Nov 2020 03:38:41 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/2-arbres-binaires/</guid>
      <description>Arbres binaires Définition Un arbre binaire est une structure de données abstraite formée d&amp;rsquo;un ensemble de nœuds organisés hiérarchiquement selon la définition par récurrence suivante :&#xA;Un arbre binaire est :&#xA;soit un arbre vide, noté $E$, ne contenant aucun nœud ; soit un nœud, appelé racine, relié à exactement deux arbres binaires $g$ et $d$, respectivement appelés sous-arbres gauche et sous-arbre droit. On note $T(r,g,d)$ l&amp;rsquo;arbre non vide dont la racine $r$ (on peut aussi indiquer l&amp;rsquo;étiquette de cette racine).</description>
    </item>
    <item>
      <title>Structures de données abstraites arborescentes : les arbres</title>
      <link>https://dlatreyte.github.io/terminales-nsi/arbres/1-introduction-arbres/</link>
      <pubDate>Thu, 05 Nov 2020 03:37:56 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/arbres/1-introduction-arbres/</guid>
      <description>La notion de listes chaînées est parfaite pour structurer un ensemble d&amp;rsquo;élements destinés à être énumérés séquentiellement. Elle permet aussi d&amp;rsquo;implémenter les structures de piles et de files. Elle n&amp;rsquo;est cependant pas adaptée aux accès spécifiques à des positions données dans la séquence, puisqu&amp;rsquo;il faut alors parcourir toutes les cellules depuis le début de la liste jusqu&amp;rsquo;à la position souhaitée (complexité en $O(N)$).&#xA;Document de référence pour ce cours Structures arborescentes Lorsqu&amp;rsquo;on manipule une information présentant une certaine hiérarchie, il est commun de la représenter graphiquement :</description>
    </item>
    <item>
      <title>Les Files</title>
      <link>https://dlatreyte.github.io/terminales-nsi/piles-files/2-files/</link>
      <pubDate>Sat, 31 Oct 2020 22:50:06 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/piles-files/2-files/</guid>
      <description>Rappel : Type de Données Abstrait (TDA) Une structure de données ou type de données abstrait est un moyen d&amp;rsquo;organiser et de manipuler les données en mémoire. Un TDA est donc définit par :&#xA;Son nom ; Sa spécification, c&amp;rsquo;est à dire la liste des manipulations/opérations que l&amp;rsquo;on peut ou pas effectuer. La spécification indique généralement la complexité de chacune des opérations prévues par le TDA. Un type de données abstrait ne dépend pas de la manière dont la structure de données est implémentée dans le langage de programmation utilisé.</description>
    </item>
    <item>
      <title>Les Piles</title>
      <link>https://dlatreyte.github.io/terminales-nsi/piles-files/1-piles/</link>
      <pubDate>Tue, 27 Oct 2020 03:40:03 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/piles-files/1-piles/</guid>
      <description>Rappel : Type de Données Abstrait (TDA) Une structure de données ou type de données abstrait est un moyen d&amp;rsquo;organiser et de manipuler les données en mémoire. Un TDA est donc définit par :&#xA;Son nom ; Sa spécification, c&amp;rsquo;est à dire la liste des manipulations/opérations que l&amp;rsquo;on peut ou pas effectuer. La spécification indique généralement la complexité de chacune des opérations prévues par le TDA. Un type de données abstrait ne dépend pas de la manière dont la structure de données est implémentée dans le langage de programmation utilisé.</description>
    </item>
    <item>
      <title>Listes Chaînées, présentation</title>
      <link>https://dlatreyte.github.io/terminales-nsi/listes-chainees/1-listes-chainees/</link>
      <pubDate>Wed, 14 Oct 2020 18:01:18 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/listes-chainees/1-listes-chainees/</guid>
      <description>Tableaux Un tableau est une structure de données dans laquelle les éléments, tous de même type, occupent des positions contiguës en mémoire. Le nombre d&amp;rsquo;éléments qu&amp;rsquo;un tableau peut contenir est déterminé à la création d&amp;rsquo;un tableau. Type Python Type Opération Exemple Complexité N&amp;rsquo;existe pas Tableau Accès à un élément tab[i] $O(1)$ Modification d&amp;rsquo;un élément tab[i] = x $O(1)$ Effacement d&amp;rsquo;un élément retire(tab, i) $O(n)$ Insertion d&amp;rsquo;un élément insere(tab, x, i) $O(n)$ Recherche d&amp;rsquo;un élément est_dans(tab, x) $O(n)$ La structure de données appelée « liste » dans le langage Python est implémentée à l&amp;rsquo;aide de tableaux dynamiques.</description>
    </item>
    <item>
      <title>Structures de données fournies avec le langage Python</title>
      <link>https://dlatreyte.github.io/terminales-nsi/types-abstraits/1-structures-integrees/</link>
      <pubDate>Tue, 13 Oct 2020 05:25:49 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/types-abstraits/1-structures-integrees/</guid>
      <description>Python possède dans la bibliothèque standard un grand nombre de structures de données, programmées de manière efficace.&#xA;Rappels : modules, fonctions Pour chaque module, on distingue :&#xA;sa réalisation (ou implémentation) : c&amp;rsquo;est le code lui-même.&#xA;son interface (API) : c&amp;rsquo;est l&amp;rsquo;énumération des fonctions définies dans le module qui sont utilisées depuis d&amp;rsquo;autres modules/programmes, les clients.&#xA;L&amp;rsquo;interface doit présenter une documentation dans laquelle tout ce que doit savoir le client doit être indiqué.</description>
    </item>
    <item>
      <title>Itérer sur les éléments d&#39;un dictionnaire</title>
      <link>https://dlatreyte.github.io/terminales-nsi/types-abstraits/2-exercices/</link>
      <pubDate>Tue, 13 Oct 2020 05:08:27 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/types-abstraits/2-exercices/</guid>
      <description>Au zoo de Beauval, il y a 5 éléphants d&amp;rsquo;Asie, 17 écureuils d&amp;rsquo;Asie, 2 pandas d&amp;rsquo;Asie, etc. On représente cet inventaire à l&amp;rsquo;aide d&amp;rsquo;un dictionnaire, de façon suivante :&#xA;1 2 3 4 5 6 7 zoo_Beauval={ &amp;#39;éléphant&amp;#39;: (&amp;#39;Asie&amp;#39;, 5), &amp;#39;écureuil&amp;#39;: (&amp;#39;Asie&amp;#39;, 17), &amp;#39;panda&amp;#39;: (&amp;#39;Asie&amp;#39;, 2), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 4) } On représente de la même façon le zoo de La Flèche :&#xA;1 2 3 4 5 6 zoo_LaFleche = { &amp;#39;ours&amp;#39;: (&amp;#39;Europe&amp;#39;, 4), &amp;#39;tigre&amp;#39;: (&amp;#39;Asie&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 11), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 3) } On souhaite se doter d&amp;rsquo;une fonction plus_grand_nombre() qui prend un zoo en paramètre et qui renvoie le nom de l&amp;rsquo;animal le plus représenté dans ce zoo.</description>
    </item>
    <item>
      <title>Tri par insertion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/2-tri-insertion/</link>
      <pubDate>Wed, 07 Oct 2020 21:53:32 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/2-tri-insertion/</guid>
      <description>Objectifs Le tri par insertion a été étudié en classe de 1ère. Dans ce document, après un rappel du cours de 1ère, nous allons implémenter une version récursive de cet algorithme et ensuite utiliser la possibilité que les fonctions en Python ont d&amp;rsquo;accepter des fonctions comme paramètres, afin de rendre plus générale et utile cette fonction de tri.&#xA;Tri du joueur de cartes Le tri par insertion est un tri « naturel » souvent qualifié de « tri du joueur de carte ».</description>
    </item>
    <item>
      <title>Programmation Fonctionnelle</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/1-programmation-fonctionnelle/</link>
      <pubDate>Tue, 06 Oct 2020 03:49:30 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/1-programmation-fonctionnelle/</guid>
      <description>Qu&amp;rsquo;est-ce que la programmation fonctionnelle ? S&amp;rsquo;il n&amp;rsquo;est pas facile de répondre précisément à cette question, on peut essayer de mettre en évidence les idées que le paradigme fonctionnel promeut :&#xA;Les fonctions doivent être des objets de première classe, c&amp;rsquo;est à dire que les fonctions doivent pouvoir être passées comme arguments à une fonction, les fonctions doivent aussi pouvoir être retournées par une fonction.&#xA;Les fonctions doivent (le plus possible) être pures, c&amp;rsquo;est à dire ne générer aucun effet de bord.</description>
    </item>
    <item>
      <title>Jeu de la vie</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-objet/5-jeu-vie/</link>
      <pubDate>Sun, 04 Oct 2020 04:35:40 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-objet/5-jeu-vie/</guid>
      <description>Le but de ce sujet est de réaliser en Python une implémentation du jeu de la vie en utilisant la programmation objet.&#xA;Un automate cellulaire consiste en une grille régulière de « cellules » contenant chacune un « état » choisi parmi un ensemble fini et qui peut évoluer au cours du temps. L&amp;rsquo;état d&amp;rsquo;une cellule au temps $t+1$ est fonction de l&amp;rsquo;état au temps $t$ d&amp;rsquo;un nombre fini de cellules appelé son « voisinage ».</description>
    </item>
    <item>
      <title>Résoudre un problème grâce aux paradigmes objet et fonctionnel</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-objet/4-fonction/</link>
      <pubDate>Thu, 01 Oct 2020 04:21:17 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-objet/4-fonction/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;illustrer une fois encore l&amp;rsquo;intérêt des différents paradigmes de programmation.&#xA;Cas d&amp;rsquo;étude : fonction avec paramètres On considère l&amp;rsquo;équation qui traduit le mouvement d&amp;rsquo;une balle lancée verticalement vers le haut avec une vitesse $\vec{v}_0$ depuis l&amp;rsquo;origine des altitudes telle que l&amp;rsquo;écrit un physicien : $$y(t) = -\dfrac{1}{2}g\, t^2 + v_0\, t$$ Ce physicien a donc tendance à considérer que $y$ est une fonction de la variable $t$ et que cette fonction dépend des paramètres $v_0$ et $g$.</description>
    </item>
    <item>
      <title>Méthodes spéciales en Python</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-objet/3-exercices/</link>
      <pubDate>Tue, 29 Sep 2020 09:51:52 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-objet/3-exercices/</guid>
      <description>Définit une classe nommée Fraction pour représenter les nombres rationnels. Cette classe doit posséder deux attributs num et denom, de type entier, qui représentent respectivement le numérateur et le dénominateur du nombre rationnel.&#xA;On demande que le dénominateur soit un entier positif.&#xA;Un corrigé de cette activité se trouve à cette adresse : https://repl.it/@dlatreyte/fraction Écrire le constructeur de cette classe. Une exception de type ValueError doit être levée si le dénominateur n&amp;rsquo;est pas un nombre entier positif.</description>
    </item>
    <item>
      <title>Simulation du fonctionnement d&#39;une banque</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-objet/2-banque/</link>
      <pubDate>Sat, 26 Sep 2020 20:06:58 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-objet/2-banque/</guid>
      <description>L&amp;rsquo;objectif de ce document est de simuler (sommairement bien sûr) le fonctionnement d&amp;rsquo;une banque. Le programme doit permettre :&#xA;La création d&amp;rsquo;une banque ; La création de comptes bancaires ; La création de personnes propriétaires de ces comptes bancaires. Une correction se trouve à cette adresse : https://repl.it/@dlatreyte/banque Classe Personne Dans un module nommé personne, créer la classe Personne dont la spécification est la suivante :&#xA;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Personne(): &amp;#34;&amp;#34;&amp;#34; Modélisation d&amp;#39;une personne.</description>
    </item>
    <item>
      <title>Programmation Objet</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-objet/1-programmation-objet/</link>
      <pubDate>Wed, 23 Sep 2020 21:07:12 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-objet/1-programmation-objet/</guid>
      <description>Programmation orientée objet Un objet est une instance d&amp;rsquo;une classe. L&amp;rsquo;un des objectifs principaux de la notion d&amp;rsquo;objet est d&amp;rsquo;organiser des programmes complexes grâce aux notions :&#xA;d&amp;rsquo;encapsulation ; d&amp;rsquo;abstraction ; d&amp;rsquo;héritage ; de polymorphisme ; Remarque : Seules les deux premières notions apparaissent dans le programme de NSI.&#xA;Encapsulation Le principe de l&amp;rsquo;encapsulation est de regrouper dans le même objet, les données (attributs) et les traitements (méthodes) qui lui sont spécifiques.</description>
    </item>
    <item>
      <title>Fourniture et utilisation d&#39;une API</title>
      <link>https://dlatreyte.github.io/terminales-nsi/modularite/4-api/</link>
      <pubDate>Tue, 22 Sep 2020 05:15:58 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/modularite/4-api/</guid>
      <description>API Une API (en anglais « Application programming interface ») est une interface de programmation d&amp;rsquo;application. Elle est destinée à être utilisée par des programmes. Le principe de ce type d&amp;rsquo;interface est le même que celui des UI (« User Interface ») ou des GUI (« Graphical User Interface ») destinées elles à un utilisateur humain.&#xA;Composée de constantes, de fonctions, de classes, elle sert de lien entre un programme et les programmes qui vont l&amp;rsquo;utiliser.</description>
    </item>
    <item>
      <title>Paradigmes de programmation</title>
      <link>https://dlatreyte.github.io/terminales-nsi/paradigmes/1-paradigmes-programmation/</link>
      <pubDate>Mon, 21 Sep 2020 20:58:45 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/paradigmes/1-paradigmes-programmation/</guid>
      <description>Langages de programmation Un langage de programmation a besoin :&#xA;des règles de grammaire qui définissent la syntaxe des expressions ; d&amp;rsquo;une sémantique qui définit le sens des expressions. Un langage peut être :&#xA;interprété : un interpréteur lit et analyse le code séquentiellement, le traduit en langage machine et lance son exécution. compilé : un compilateur lit et analyse le code puis le traduit en langage machine. Par la suite l&amp;rsquo;exécutable généré peut être lancé.</description>
    </item>
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/modularite/3-exercices/</link>
      <pubDate>Sun, 20 Sep 2020 05:12:32 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/modularite/3-exercices/</guid>
      <description>Enquêter sur une erreur dans un calcul de $\pi$ La somme des inverses des carrés des nombres entiers converge vers $\dfrac{\pi^2}{6}$.&#xA;$$\sum_{k=1}^{\infty} \dfrac{1}{k^2} = \dfrac{\pi^2}{6}$$&#xA;On utilise cette formule pour trouver une approximation de $\pi$. 1 2 3 4 5 6 7 8 9 10 11 import math def terme(k: int) -&amp;gt; float: return 1 / (k**2) def approxpi(n: int) -&amp;gt; float: s = 0 # utilise les termes jusqu’à 1/n**2 inclus for k in range(n): s = s + terme(k) return math.</description>
    </item>
    <item>
      <title>Modules et exceptions</title>
      <link>https://dlatreyte.github.io/terminales-nsi/modularite/1-modules/</link>
      <pubDate>Tue, 15 Sep 2020 05:06:32 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/modularite/1-modules/</guid>
      <description>Ce chapitre se concentre sur les modules de Python et sur les modalités d&amp;rsquo;importation des données des modules dans l&amp;rsquo;environnement de travail.&#xA;L&amp;rsquo;objectif de ce document est de souligner l&amp;rsquo;importance d&amp;rsquo;un code modulaire, c&amp;rsquo;est à dire d&amp;rsquo;un code qui :&#xA;puisse être utilisé dans plusieurs programmes ; puisse être documenté précisément ; soit suffisamment compact pour être étudié avec soin et en particulier testé. Qu&amp;rsquo;est-ce qu&amp;rsquo;un module ? Un module permet d&amp;rsquo;organiser logiquement le code Python.</description>
    </item>
    <item>
      <title>Capitalisation d&#39;une valeur</title>
      <link>https://dlatreyte.github.io/terminales-nsi/modularite/2-capitalisation/</link>
      <pubDate>Tue, 15 Sep 2020 05:05:07 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/modularite/2-capitalisation/</guid>
      <description>Cette séance a pour objectif de vous familiariser avec la création et la manipulation de modules.&#xA;Comme il est maintenant de tradition vous diviserez le code de votre programme principal en trois parties:&#xA;Importation des modules ; Définitions des fonctions ; Partie principale (lieu d&amp;rsquo;appel des fonctions). Vous documenterez aussi systématiquement vos fonctions (une aide sera fournie dans les questions relatives à la définition de chacune de ces fonctions).&#xA;En mathématique, on démontre qu&amp;rsquo;un capital placé à un certain taux d&amp;rsquo;intérêt évolue selon la formule :</description>
    </item>
    <item>
      <title>Rappels d&#39;algorithmique</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-4-rappels-algorithmique/</link>
      <pubDate>Sat, 12 Sep 2020 17:46:07 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-4-rappels-algorithmique/</guid>
      <description>Algorithmique Un algorithme est une suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser afin de résoudre un problème. En informatique, pour qu&amp;rsquo;un algorithme puisse être implémenté, il est nécessaire de s&amp;rsquo;assurer que la « suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser » s&amp;rsquo;effectue en une durée finie .&#xA;Lorsqu&amp;rsquo;on élabore ou étudie un algorithme, il est donc nécessaire de vérifier :&#xA;Sa finitude : Il doit se terminer en un temps fini.</description>
    </item>
    <item>
      <title>Recherche d&#39;un élément dans un tableau : algorithmes itératifs et récursifs</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-3-recursivite-recherches/</link>
      <pubDate>Wed, 09 Sep 2020 21:33:15 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-3-recursivite-recherches/</guid>
      <description>Recherche d&amp;rsquo;un élément dans un tableau La recherche d&amp;rsquo;éléments dans un tableau a déjà été évoquée en classe de première. Les deux algorithmes mis en œuvre à cette occasion, la recherche linéaire et la recherche dichotomique, utilisaient des boucles.&#xA;L&amp;rsquo;objectif de cette séance est de rapidement revoir ces algorithmes et de mettre en œuvres des algorithmes récursifs de même complexité. Quatre algorithmes de recherche vont donc être implémentés :&#xA;La recherche linéaire itérative ; La recherche linéaire récursive ; La recherche dichotomique itérative ; La recherche dichotomique récursive.</description>
    </item>
    <item>
      <title>La récursivité appliquée aux chaînes de caractères et aux listes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-2-recursivite-chaines-listes/</link>
      <pubDate>Tue, 08 Sep 2020 04:53:31 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-2-recursivite-chaines-listes/</guid>
      <description>Introduction Une chaîne de caractère est une structure de données qui permet de rassembler en un unique objet une succession ordonnée de caractères. Ainsi, une définition récursive d&amp;rsquo;une chaîne de caractères pourrait être :&#xA;Une chaîne de caractères est :&#xA;soit la chaîne de caractères vide ; soit constituée de son premier caractère et du reste des caractères qui forment aussi une chaîne de caractères (éventuellement vide). Une liste est une structure de données qui permet de rassembler en un unique objet une succession ordonnée d&amp;rsquo;objets (ou de valeurs).</description>
    </item>
    <item>
      <title>Récursivité sur les entiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-1-recursivite-sur-entiers/</link>
      <pubDate>Sat, 05 Sep 2020 18:34:00 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-1-recursivite-sur-entiers/</guid>
      <description>To understand recursion, you must first understand recursion. La récurrence est un raisonnement mathématique courant et parmi les plus puissants pour démontrer des théorèmes ou construire des objets. Par exemple, on l&amp;rsquo;utilise dans un cours de mathématique de lycée pour montrer que :&#xA;Pour tout entier $n \geqslant 0$, on a : $1 + 2 + 3 + \ldots + n = \dfrac{n(n+1)}{2}$ ; Un entier naturel n&amp;rsquo;est autre que 0 ou le successeur d&amp;rsquo;un entier naturel (0 est 0, 1 est le successeur de 0, 2 est le successeur de 1, &amp;hellip;).</description>
    </item>
    <item>
      <title>Problème du sac à dos</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-02/</link>
      <pubDate>Sun, 23 Aug 2020 23:27:12 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-02/</guid>
      <description>Au programme Algorithmique Contenus Capacités attendues Commentaires Algorithmes gloutons Résoudre un problème grâce à un algorithme glouton. Exemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale. </description>
    </item>
    <item>
      <title>Algorithmes gloutons, problème du rendu de monnaie</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-01/</link>
      <pubDate>Sun, 23 Aug 2020 23:00:09 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-01/</guid>
      <description>Au programme Algorithmique Contenus Capacités attendues Commentaires Algorithmes gloutons Résoudre un problème grâce à un algorithme glouton. Exemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale. Introduction Les algorithmes gloutons forment une catégorie d&amp;rsquo;algorithmes permettant de parvenir à une solution pour un problème d&amp;rsquo;optimisation qui vise à maximiser/minimiser une quantité (plus court chemin (GPS), plus petite durée d&amp;rsquo;exécution, meilleure organisation d&amp;rsquo;un emploi du temps, etc.</description>
    </item>
    <item>
      <title>Les différentes erreurs lorsqu&#39;on calcule à l&#39;aide d&#39;un ordinateur</title>
      <link>https://dlatreyte.github.io/superieur/calcul_numerique_et_erreurs/</link>
      <pubDate>Fri, 21 Aug 2020 14:08:45 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/superieur/calcul_numerique_et_erreurs/</guid>
      <description>Dans ce document, on s&amp;rsquo;intéresse au différentes erreurs qui interviennent lorsqu&amp;rsquo;on effectue des calculs à l&amp;rsquo;aide d&amp;rsquo;un ordinateur. On prend pour exemple le calcul numérique de la dérivée d&amp;rsquo;une fonction, qu&amp;rsquo;elle soit définie analytiquement ou numériquement (par une table de valeurs).&#xA;Dérivation d&amp;rsquo;une fonction analytique &amp;mdash; idée simple Introduction Le nombre dérivé $f&amp;rsquo;(x)$ en un point $x \in \mathbb{R}$, d&amp;rsquo;une fonction1 : $$ \begin{array}{l|rcl} f: &amp;amp; \mathbb{R} &amp;amp; \longrightarrow &amp;amp; \mathbb{R} \cr &amp;amp; x &amp;amp; \longmapsto &amp;amp; f(x) \end{array} $$</description>
    </item>
  </channel>
</rss>
