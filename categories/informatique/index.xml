<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Informatique on Accueil</title>
    <link>https://dlatreyte.github.io/categories/informatique/</link>
    <description>Recent content in Informatique on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Sun, 20 Sep 2020 05:12:32 +0400</lastBuildDate>
    
	<atom:link href="https://dlatreyte.github.io/categories/informatique/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</link>
      <pubDate>Sun, 20 Sep 2020 05:12:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</guid>
      <description>Enquêter sur une erreur dans un calcul de $\pi$ La somme des inverses des carrés des nombres entiers converge vers $\dfrac{\pi^2}{6}$.
$$\sum_{k=1}^{\infty} \dfrac{1}{k^2} = \dfrac{\pi^2}{6}$$
On utilise cette formule pour trouver une approximation de $\pi$. 1 2 3 4 5 6 7 8 9 10  import math def terme(k: int) -&amp;gt; float: return 1 / (k ** 2) def approxpi(n: int) -&amp;gt; float: s = 0 # utilise les termes jusqu’à 1/n**2 inclus for k in range(n): s = s + terme(k) return math.</description>
    </item>
    
    <item>
      <title>Modules et exceptions</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</link>
      <pubDate>Tue, 15 Sep 2020 05:06:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</guid>
      <description>Ce chapitre se concentre sur les modules de Python et sur les modalités d&amp;rsquo;importation des données des modules dans l&amp;rsquo;environnement de travail.
L&amp;rsquo;objectif de ce document est de souligner l&amp;rsquo;importance d&amp;rsquo;un code modulaire, c&amp;rsquo;est à dire d&amp;rsquo;un code qui :
 puisse être utilisé dans plusieurs programmes ; puisse être documenté précisément ; soit suffisamment compact pour être étudié avec soin et en particulier testé.   Qu&amp;rsquo;est-ce qu&amp;rsquo;un module ?</description>
    </item>
    
    <item>
      <title>Capitalisation d&#39;une valeur</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</link>
      <pubDate>Tue, 15 Sep 2020 05:05:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</guid>
      <description>Cette séance a pour objectif de vous familiariser avec la création et la manipulation de modules.
Comme il est maintenant de tradition vous diviserez le code de votre programme principal en trois parties:
 Importation des modules ; Définitions des fonctions ; Partie principale (lieu d&amp;rsquo;appel des fonctions).  Vous documenterez aussi systématiquement vos fonctions (une aide sera fournie dans les questions relatives à la définition de chacune de ces fonctions).</description>
    </item>
    
    <item>
      <title>Introduction à l&#39;algorithmique, recherche d&#39;un élément dans un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</link>
      <pubDate>Sat, 12 Sep 2020 17:46:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</guid>
      <description>Algorithmique Introduction Un algorithme est une suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser afin de résoudre un problème.  En informatique, pour qu&amp;rsquo;un algorithme puisse être implémenté, il est nécessaire de s&amp;rsquo;assurer que la « suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser » s&amp;rsquo;effectue en une durée finie .
Lorsqu&amp;rsquo;on élabore ou étudie un algorithme, il est donc nécessaire de vérifier :
 Sa finitude : Il doit se terminer en un temps fini.</description>
    </item>
    
    <item>
      <title>Recherche d&#39;un élément dans un tableau&amp;nbsp;: algorithmes itératifs et récursifs</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</link>
      <pubDate>Wed, 09 Sep 2020 21:33:15 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</guid>
      <description>Recherche d&amp;rsquo;un élément dans un tableau La recherche d&amp;rsquo;éléments dans un tableau a déjà été évoquée en classe de première. Les deux algorithmes mis en œuvre à cette occasion, la recherche linéaire et la recherche dichotomique, utilisaient des boucles.
L&amp;rsquo;objectif de cette séance est de rapidement revoir ces algorithmes et de mettre en œuvres des algorithmes récursifs de même complexité. Quatre algorithmes de recherche vont donc être implémentés :
 La recherche linéaire itérative ; La recherche linéaire récursive ; La recherche dichotomique itérative ; La recherche dichotomique récursive.</description>
    </item>
    
    <item>
      <title>La récursivité appliquée aux chaînes de caractères et aux listes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</link>
      <pubDate>Tue, 08 Sep 2020 04:53:31 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</guid>
      <description>Penser à écrire, pour chacune des fonctions ci-dessous, sa spécification ainsi qu&amp;rsquo;un jeu de tests.
Recherche dans une chaîne de caractères Écrire une fonction récursive nommée est_dans, qui, à partir d&amp;rsquo;un caractère e et d&amp;rsquo;une chaîne de caractères c, détermine si ce caractère appartient à la chaîne.
Tester cette fonction.
Remarque : la fonction est_dans est un prédicat.
    Solution  def est_dans(e: str, c: str) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34; Détermine si le caractère e est dans la chaîne c.</description>
    </item>
    
    <item>
      <title>Récursivité sur les entiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</link>
      <pubDate>Sat, 05 Sep 2020 18:34:00 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</guid>
      <description>La récurrence est un raisonnement mathématique courant et parmi les plus puissants pour démontrer des théorèmes ou construire des objets. Par exemple, on l&amp;rsquo;utilise dans un cours de mathématique de lycée pour montrer que :
 Pour tout entier $n \geqslant 0$, on a : $1 + 2 + 3 + \ldots + n = \dfrac{n(n+1)}{2}$ ; Un entier naturel n&amp;rsquo;est autre que 0 ou le successeur d&amp;rsquo;un entier naturel (0 est 0, 1 est le successeur de 0, 2 est le successeur de 1, &amp;hellip;).</description>
    </item>
    
    <item>
      <title>Problème du sac à dos</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-02/</link>
      <pubDate>Sun, 23 Aug 2020 23:27:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-02/</guid>
      <description>Au programme Algorithmique    Contenus Capacités attendues Commentaires     Algorithmes gloutons Résoudre un problème grâce à un algorithme glouton. Exemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale.    </description>
    </item>
    
    <item>
      <title>Algorithmes gloutons, problème du rendu de monnaie</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-01/</link>
      <pubDate>Sun, 23 Aug 2020 23:00:09 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-23/chap-23-01/</guid>
      <description>Au programme Algorithmique    Contenus Capacités attendues Commentaires     Algorithmes gloutons Résoudre un problème grâce à un algorithme glouton. Exemples : problèmes du sac à dos ou du rendu de monnaie. Les algorithmes gloutons constituent une méthode algorithmique parmi d’autres qui seront vues en terminale.    Introduction Les algorithmes gloutons forment une catégorie d&amp;rsquo;algorithmes permettant de parvenir à une solution pour un problème d&amp;rsquo;optimisation qui vise à maximiser/minimiser une quantité (plus court chemin (GPS), plus petite durée d&amp;rsquo;exécution, meilleure organisation d&amp;rsquo;un emploi du temps, etc.</description>
    </item>
    
    <item>
      <title>Les différentes erreurs lorsqu&#39;on calcule à l&#39;aide d&#39;un ordinateur</title>
      <link>https://dlatreyte.github.io/superieur/calcul_numerique_et_erreurs/</link>
      <pubDate>Fri, 21 Aug 2020 14:08:45 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/superieur/calcul_numerique_et_erreurs/</guid>
      <description>Dans ce document, on s&amp;rsquo;intéresse au différentes erreurs qui interviennent lorsqu&amp;rsquo;on effectue des calculs à l&amp;rsquo;aide d&amp;rsquo;un ordinateur. On prend pour exemple le calcul numérique de la dérivée d&amp;rsquo;une fonction, qu&amp;rsquo;elle soit définie analytiquement ou numériquement (par une table de valeurs).
Dérivation d&amp;rsquo;une fonction analytique &amp;mdash; idée simple Introduction Le nombre dérivé $f&amp;rsquo;(x)$ en un point $x \in \mathbb{R}$, d&amp;rsquo;une fonction1 : $$ \begin{array}{l|rcl} f: &amp;amp; \mathbb{R} &amp;amp; \longrightarrow &amp;amp; \mathbb{R} \cr &amp;amp; x &amp;amp; \longmapsto &amp;amp; f(x) \end{array} $$</description>
    </item>
    
    <item>
      <title>Premiers pas en programmation... et en Python</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</link>
      <pubDate>Sat, 14 Sep 2019 21:37:45 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</guid>
      <description>On appelle informatique le traitement automatisé des informations par un ordinateur. Cette discipline s&amp;rsquo;appuie sur la programmation, activité qui consiste à apprendre à un ordinateur à effectuer des tâches qu&amp;rsquo;il n&amp;rsquo;est pas capable d&amp;rsquo;exécuter à sa conception. L&amp;rsquo;écriture d&amp;rsquo;un programme nécessite l&amp;rsquo;utilisation d&amp;rsquo;un langage de programmation. Dans ce cours nous utiliserons Python.
Au programme Langages et programmation    Contenus Capacités attendues Commentaires     Constructions élémentaires Mettre en évidence un corpus de constructions élémentaires.</description>
    </item>
    
    <item>
      <title>Éléments d&#39;histoire et d&#39;architecture des ordinateurs</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-01/chap-01/</link>
      <pubDate>Tue, 10 Sep 2019 23:50:18 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-01/chap-01/</guid>
      <description>Au programme Histoire de l’informatique    Contenus Capacités attendues Commentaires     Événements clés de l’histoire de l’informatique Situer dans le temps les principaux événements de l’histoire de l’informatique et leurs protagonistes. Ces repères historiques seront construits au fur et à mesure de la présentation des concepts et techniques.    Langages et programmation    Contenus Capacités attendues Commentaires     Diversité et unité des langages de programmation Repérer, dans un nouveau langage de programmation, les traits communs et les traits particuliers à ce langage.</description>
    </item>
    
  </channel>
</rss>