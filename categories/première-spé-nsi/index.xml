<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Première Spé NSI on Accueil</title>
    <link>https://dlatreyte.github.io/categories/premi%C3%A8re-sp%C3%A9-nsi/</link>
    <description>Recent content in Première Spé NSI on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Sun, 29 Aug 2021 16:36:24 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/categories/premi%C3%A8re-sp%C3%A9-nsi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tester ses fonctions avec &#39;assert&#39;</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-05/2-assert/</link>
      <pubDate>Sun, 29 Aug 2021 16:36:24 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-05/2-assert/</guid>
      <description>Dans le document 5,1, nous avons insisté sur l&amp;rsquo;importance de la spécification d&amp;rsquo;une fonction et sur celle d&amp;rsquo;un jeu de tests.&#xA;Dans ce document, nous allons découvrir une nouvelle façon de tester ses fonctions.&#xA;Le mot clé assert Le mot clé assert est utilisé afin de s&amp;rsquo;assurer de la robustesse d&amp;rsquo;une fonction. Il ne doit jamais être utilisé au sein d&amp;rsquo;un programme pour lever une exception ; il ne faut donc pas le confondre avec le mot clé raise.</description>
    </item>
    <item>
      <title>Contrôle du flot d&#39;exécution d&#39;un programme : structures iteratives</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-04/2-structures-iteratives/</link>
      <pubDate>Sun, 29 Aug 2021 00:17:52 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-04/2-structures-iteratives/</guid>
      <description>Ce chapitre reprend l&amp;rsquo;étude de structures de contrôles, c&amp;rsquo;est à dire d&amp;rsquo;instructions qui permettent de modifier le « flot d&amp;rsquo;exécution implicite » d&amp;rsquo;un programme.&#xA;Après les structures conditionnelles (ou alternatives), les structures itératives (ou boucles) sont introduites.&#xA;Introduction Les boucles sont des instructions répétitives. Comme les tests conditionnels, elles nécessitent la définition de blocs d’instructions. Les instructions de ces blocs sont répétées tant qu&amp;rsquo;une condition d’arrêt n&amp;rsquo;est pas vérifiée. Chaque passage dans la boucle s&amp;rsquo;appelle une itération.</description>
    </item>
    <item>
      <title>Contrôle du flot d&#39;exécution d&#39;un programme : l&#39;alternative</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-04/1-alternative/</link>
      <pubDate>Fri, 27 Aug 2021 16:34:09 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-04/1-alternative/</guid>
      <description>Booléens et expressions booléennes Une grandeur booléenne est une grandeur qui ne peut prendre que deux valeurs : Vrai ou Faux, ou 0 ou 1, ou …). Dans le langage Python, les valeurs booléennes s&amp;rsquo;écrivent True et False. La fonction bool transforme n&amp;rsquo;importe quel argument en valeur booléenne — tout argument à valeur nulle (entier 0, flottant 0.0, chaîne de caractères &amp;quot;&amp;quot;, liste vide list(), etc.) est converti en valeur False, toute autre valeur pour l&amp;rsquo;argument devient la valeur True.</description>
    </item>
    <item>
      <title>Quelques dessins simples avec une tortue</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-sept/chap-7/</link>
      <pubDate>Sat, 12 Oct 2019 18:10:22 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-sept/chap-7/</guid>
      <description>1. Présentation de la « tortue graphique » La « tortue graphique » a été inventée à la fin des années 60 par Seymour Papert et ses collègues du MIT (célèbre université américaine) pour permettre de rendre l&amp;rsquo;apprentissage de la programmation plus ludique. Elle faisait alors partie du langage Logo, spécifiquement développé pour être utilisé par de jeunes enfants.&#xA;Le nom « tortue graphique » suggère la façon dont les figures géométriques vont être dessinées à l&amp;rsquo;écran.</description>
    </item>
    <item>
      <title>Contrôle du flot d’exécution d’un programme, les structures itératives</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-six/chap-06/</link>
      <pubDate>Sat, 28 Sep 2019 17:41:06 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-six/chap-06/</guid>
      <description>Ce chapitre reprend l&amp;rsquo;étude de structures de contrôles, c&amp;rsquo;est à dire d&amp;rsquo;instructions qui permettent de modifier le « flot d&amp;rsquo;exécution implicite » d&amp;rsquo;un programme.&#xA;Après les structures conditionnelles (ou alternatives), les structures itératives (ou boucles) sont introduites.&#xA;Structures itératives Les boucles sont des instructions répétitives. Comme les tests conditionnels, elles nécessitent la définition de blocs d’instructions. Les instructions de ces blocs sont répétées tant qu&amp;rsquo;une condition d’arrêt n&amp;rsquo;est pas vérifiée. Chaque passage dans la boucle s&amp;rsquo;appelle une itération.</description>
    </item>
    <item>
      <title>Contrôle du flot d’exécution d’un programme, les structures conditionnelles</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-quatre/chap-04/</link>
      <pubDate>Sat, 28 Sep 2019 17:40:46 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-quatre/chap-04/</guid>
      <description></description>
    </item>
    <item>
      <title>Variables, affectations</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-03/chap-03/</link>
      <pubDate>Sat, 28 Sep 2019 11:28:37 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-03/chap-03/</guid>
      <description>Variables Une variable est une zone de la mémoire repérée par un identificateur. Cet identificateur permet de modifier ou de faire appel au contenu de cette zone de la mémoire lors du déroulement du programme. La définition d&amp;rsquo;une variable donnée ci-dessus est générale. Dans le langage Python, il est plus correct d&amp;rsquo;envisager une variable comme une étiquette (ou un alias) permettant d&amp;rsquo;accéder à un objet (nombre entier, nombre décimal, chaîne de caractères, &amp;hellip;).</description>
    </item>
    <item>
      <title>Langages et programmation</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</link>
      <pubDate>Sat, 14 Sep 2019 21:37:45 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</guid>
      <description>À quoi a-t-on accès lorsqu&amp;rsquo;on utilise un langage de programmation ? Un langage de programmation doit :&#xA;fournir des objets (ou types) primitifs ; posséder une bibliothèque de fonctions prédéfinies ; permettre la manipulation des objets primitifs et des fonctions prédéfinies ; établir des règles qui permettent de construire de nouveaux objets (ou types) ou de nouvelles fonctions par combinaison des types primitifs et des fonctions prédéfinies. Nous allons aborder chacun de ces points.</description>
    </item>
    <item>
      <title>Éléments d&#39;histoire et d&#39;architecture des ordinateurs</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-01/chap-01/</link>
      <pubDate>Tue, 10 Sep 2019 23:50:18 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-01/chap-01/</guid>
      <description>Au programme Histoire de l’informatique Contenus Capacités attendues Commentaires Événements clés de l’histoire de l’informatique Situer dans le temps les principaux événements de l’histoire de l’informatique et leurs protagonistes. Ces repères historiques seront construits au fur et à mesure de la présentation des concepts et techniques. Langages et programmation Contenus Capacités attendues Commentaires Diversité et unité des langages de programmation Repérer, dans un nouveau langage de programmation, les traits communs et les traits particuliers à ce langage.</description>
    </item>
  </channel>
</rss>
