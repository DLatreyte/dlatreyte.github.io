<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terminales Spé NSI on Accueil</title>
    <link>https://dlatreyte.github.io/categories/terminales-sp%C3%A9-nsi/</link>
    <description>Recent content in Terminales Spé NSI on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Tue, 10 Nov 2020 05:04:12 +0400</lastBuildDate>
    
	<atom:link href="https://dlatreyte.github.io/categories/terminales-sp%C3%A9-nsi/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Arbres Binaires Recherche</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/3-arbres-binaires-recherche/</link>
      <pubDate>Tue, 10 Nov 2020 05:04:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/3-arbres-binaires-recherche/</guid>
      <description>Introduction Une utilisation particulière des arbres binaires est la notion d’arbre binaire de recherche. On suppose que les valeurs des nœuds sont des objets comparables entre eux : pour fixer les idées, on considère n’avoir que des entiers.
Un arbre binaire de recherche, ou ABR, est un arbre binaire avec la propriété suivante : pour tout nœud $x$, tous les nœuds situés dans le sous-arbre gauche de $x$ ont une valeur $\leqslant val(x)$, et tous ceux situés dans son sous-arbre droit ont une valeur $\geqslant val(x)$.</description>
    </item>
    
    <item>
      <title>Les arbres binaires</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/2-arbres-binaires/</link>
      <pubDate>Thu, 05 Nov 2020 03:38:41 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/2-arbres-binaires/</guid>
      <description>Le corrigé de l&amp;rsquo;activité se trouve ici  Arbres binaires Définition   Un arbre binaire est un arbre de degré 2 (dont les nœuds sont au plus de degré 2).
  Les enfants d’un nœud sont lus de gauche à droite et sont appelés : fils gauche et fils droit.
   Pour simplifier la présentation, on va considérer que chaque nœud possède exactement deux fils mais que ceux-ci peuvent être vides (None par exemple).</description>
    </item>
    
    <item>
      <title>Structures de données abstraites arborescentes : les arbres</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/1-introduction-arbres/</link>
      <pubDate>Thu, 05 Nov 2020 03:37:56 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/1-introduction-arbres/</guid>
      <description>La notion de listes chaînées est parfaite pour structurer un ensemble d&amp;rsquo;élements destinés à être énumérés séquentiellement. Elle permet aussi d&amp;rsquo;implémenter les structures de piles et de files. Elle n&amp;rsquo;est cependant pas adaptée aux accès spécifiques à des positions données dans la séquence, puisqu&amp;rsquo;il faut alors parcourir toutes les cellules depuis le début de la liste jusqu&amp;rsquo;à la position souhaitée (complexité en $O(N)$).
 Document de référence pour ce cours Structures arborescentes Lorsqu&amp;rsquo;on manipule une information présentant une certaine hiérarchie, il est commun de la représenter graphiquement :</description>
    </item>
    
    <item>
      <title>Les Files</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-8/2-files/</link>
      <pubDate>Sat, 31 Oct 2020 22:50:06 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-8/2-files/</guid>
      <description>Rappel : Type de Données Abstrait (TDA) Une structure de données ou type de données abstrait est un moyen d&amp;rsquo;organiser et de manipuler les données en mémoire. Un TDA est donc définit par :
 Son nom ; Sa spécification, c&amp;rsquo;est à dire la liste des manipulations/opérations que l&amp;rsquo;on peut ou pas effectuer.
La spécification indique généralement la complexité de chacune des opérations prévues par le TDA.  Un type de données abstrait ne dépend pas de la manière dont la structure de données est implémentée dans le langage de programmation utilisé.</description>
    </item>
    
    <item>
      <title>Les Piles</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-8/1-piles/</link>
      <pubDate>Tue, 27 Oct 2020 03:40:03 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-8/1-piles/</guid>
      <description>Rappel : Type de Données Abstrait (TDA) Une structure de données ou type de données abstrait est un moyen d&amp;rsquo;organiser et de manipuler les données en mémoire. Un TDA est donc définit par :
 Son nom ; Sa spécification, c&amp;rsquo;est à dire la liste des manipulations/opérations que l&amp;rsquo;on peut ou pas effectuer.
La spécification indique généralement la complexité de chacune des opérations prévues par le TDA.  Un type de données abstrait ne dépend pas de la manière dont la structure de données est implémentée dans le langage de programmation utilisé.</description>
    </item>
    
    <item>
      <title>Listes Chaînées</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-7/1-listes-chainees/</link>
      <pubDate>Wed, 14 Oct 2020 18:01:18 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-7/1-listes-chainees/</guid>
      <description>Un corrigé de la section 1 se trouve ici
  Un corrigé des sections suivantes se trouve ici
   Tableaux  Un tableau est une structure de données dans laquelle les éléments, de même type, occupent des positions contiguës en mémoire. Le nombre d&amp;rsquo;éléments qu&amp;rsquo;un tableau peut contenir est déterminé à la création d&amp;rsquo;un tableau.      Type Python Type abstrait Opération Exemple Complexité     N&amp;rsquo;existe pas Tableau Accès à un élément tab[i] $O(1)$     Modification d&amp;rsquo;un élément tab[i] = x $O(1)$     Effacement d&amp;rsquo;un élément retire(tab, i) $O(n)$     Insertion d&amp;rsquo;un élément insere(tab, x, i) $O(n)$     Recherche d&amp;rsquo;un élément est_dans(tab, x) $O(n)$     La structure de données appelée « liste » dans le langage Python est en fait un tableau dynamique.</description>
    </item>
    
    <item>
      <title>Structures de données fournies avec le langage Python</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/1-structures-integrees/</link>
      <pubDate>Tue, 13 Oct 2020 05:25:49 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/1-structures-integrees/</guid>
      <description>Python possède dans la bibliothèque standard un grand nombre de structures de données, programmées de manière efficace.
Pourquoi différentes structures de données ? Les structures de données organisent différemment les données que le programme traite. Le langage Python fournissant le type list, on pourrait se demander pourquoi ne pas systématiquement l&amp;rsquo;utiliser et pourquoi devoir apprendre de nouveaux types.
En fait, la spécialisation des structures de données rend la programmation plus simple (utilisation de l&amp;rsquo;API) et plus efficace (complexité).</description>
    </item>
    
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/2-exercices/</link>
      <pubDate>Tue, 13 Oct 2020 05:08:27 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/2-exercices/</guid>
      <description>Itérer sur les éléments d&amp;rsquo;un dictionnaire Au zoo de Beauval, il y a 5 éléphants d&amp;rsquo;Asie, 17 écureuils d&amp;rsquo;Asie, 2 pandas d&amp;rsquo;Asie, etc. On représente cet inventaire à l&amp;rsquo;aide d&amp;rsquo;un dictionnaire, de façon suivante :
zoo_Beauval={ &amp;#39;éléphant&amp;#39;: (&amp;#39;Asie&amp;#39;, 5), &amp;#39;écureuil&amp;#39;: (&amp;#39;Asie&amp;#39;, 17), &amp;#39;panda&amp;#39;: (&amp;#39;Asie&amp;#39;, 2), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 4) } On représente de la même façon le zoo de La Flèche :
zoo_LaFleche = { &amp;#39;ours&amp;#39;: (&amp;#39;Europe&amp;#39;, 4), &amp;#39;tigre&amp;#39;: (&amp;#39;Asie&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 11), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 3) } On souhaite se doter d&amp;rsquo;une fonction plus_grand_nombre() qui prend un zoo en paramètre et qui renvoie le nom de l&amp;rsquo;animal le plus représenté dans ce zoo.</description>
    </item>
    
    <item>
      <title>Modéliser les notes des élèves</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/3-annale/</link>
      <pubDate>Tue, 13 Oct 2020 05:06:51 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/3-annale/</guid>
      <description>Partie 1 : Modélisation simpliste On modélise les notes d&amp;rsquo;une élève de la faon suivante :
notes_de_lea = [12, 14, 3, 16, 17, 2, 13, 19]  Quel est le type de notes_de_lea ?  un int une liste un tuple un dictionnaire autre chose   Que vaut l&amp;rsquo;expression notes_de_lea[2] ?  3 14 6 5 autre chose   Quelle instruction permet d&amp;rsquo;ajouter une note de 15 à cette structure de données ?</description>
    </item>
    
    <item>
      <title>Tri par insertion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-5/2-tri-insertion/</link>
      <pubDate>Wed, 07 Oct 2020 21:53:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-5/2-tri-insertion/</guid>
      <description>Objectifs  Le tri par insertion a été étudié en classe de 1ère. Dans ce document, après un rappel du cours de 1ère, nous allons implémenter une version récursive de cet algorithme et ensuite utiliser la possibilité que les fonctions en Python ont d&amp;rsquo;accepter des fonctions comme paramètres, afin de rendre plus générale et utile cette fonction de tri.
 Tri du joueur de cartes Le tri par insertion est un tri « naturel » souvent qualifié de « tri du joueur de carte ».</description>
    </item>
    
    <item>
      <title>Programmation Fonctionnelle</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-5/1-programmation-fonctionnelle/</link>
      <pubDate>Tue, 06 Oct 2020 03:49:30 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-5/1-programmation-fonctionnelle/</guid>
      <description>Qu&amp;rsquo;est-ce que la programmation fonctionnelle ? S&amp;rsquo;il n&amp;rsquo;est pas facile de répondre précisément à cette question, on peut essayer de mettre en évidence les idées que le paradigme fonctionnel promeut :
  Les fonctions doivent être des objets de première classe, c&amp;rsquo;est à dire que les fonctions doivent pouvoir être passées comme arguments à une fonction, les fonctions doivent aussi pouvoir être retournées par une fonction.
  Les fonctions doivent (le plus possible) être pures, c&amp;rsquo;est à dire ne générer aucun effet de bord.</description>
    </item>
    
    <item>
      <title>Jeu de la vie</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/5-jeu-vie/</link>
      <pubDate>Sun, 04 Oct 2020 04:35:40 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/5-jeu-vie/</guid>
      <description>Le but de ce sujet est de réaliser en Python une implémentation du jeu de la vie en utilisant la programmation objet.
 Le jeu de la vie a été inventé par le mathématicien britannique John H. Conway (1937-2020). C’est un exemple de ce qu’on appelle un automate cellulaire. Il se déroule sur un tableau rectangulaire $(L \times H)$ de cellules. Une cellule est représentée par ses coordonnées $x$ et $y$ qui vérifient $0 \leqslant x &amp;lt; L$ et $0 \leqslant y &amp;lt; H$.</description>
    </item>
    
    <item>
      <title>Résoudre un problème grâce aux paradigmes objet et fonctionnel</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/4-fonction/</link>
      <pubDate>Thu, 01 Oct 2020 04:21:17 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/4-fonction/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;illustrer une fois encore l&amp;rsquo;intérêt des différents paradigmes de programmation.
Cas d&amp;rsquo;étude : fonction avec paramètres On considère l&amp;rsquo;équation qui traduit le mouvement d&amp;rsquo;une balle lancée verticalement vers le haut avec une vitesse $\vec{v}_0$ depuis l&amp;rsquo;origine des altitudes telle que l&amp;rsquo;écrit un physicien : $$y(t) = -\dfrac{1}{2}g\, t^2 + v_0\, t$$ Ce physicien a donc tendance à considérer que $y$ est une fonction de la variable $t$ et que cette fonction dépend des paramètres $v_0$ et $g$.</description>
    </item>
    
    <item>
      <title>Méthodes spéciales</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/3-exercices/</link>
      <pubDate>Tue, 29 Sep 2020 09:51:52 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/3-exercices/</guid>
      <description>Définit une classe nommée Fraction pour représenter les nombres rationnels. Cette classe doit posséder deux attributs num et denom, de type entier, qui représentent respectivement le numérateur et le dénominateur du nombre rationnel.
On demande que le dénominateur soit un entier positif.
Un corrigé de cette activité se trouve à cette adresse : https://repl.it/@dlatreyte/fraction   Écrire le constructeur de cette classe. Une exception de type ValueError doit être levée si le dénominateur n&amp;rsquo;est pas un nombre entier positif.</description>
    </item>
    
    <item>
      <title>Simulation du fonctionnement d&#39;une banque</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/2-banque/</link>
      <pubDate>Sat, 26 Sep 2020 20:06:58 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/2-banque/</guid>
      <description>L&amp;rsquo;objectif de ce document est de simuler (sommairement bien sûr) le fonctionnement d&amp;rsquo;une banque. Le programme doit permettre :
 La création d&amp;rsquo;une banque ; La création de comptes bancaires ; La création de personnes propriétaires de ces comptes bancaires.  Une correction se trouve à cette adresse : https://repl.it/@dlatreyte/banque Classe Personne Dans un module nommé personne, créer la classe Personne dont la spécification est la suivante :
class Personne(): &amp;#34;&amp;#34;&amp;#34; Modélisation d&amp;#39;une personne.</description>
    </item>
    
    <item>
      <title>Programmation Objet</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/1-programmation-objet/</link>
      <pubDate>Wed, 23 Sep 2020 21:07:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/1-programmation-objet/</guid>
      <description>Programmation orientée objet L&amp;rsquo;un des objectifs principaux de la notion d&amp;rsquo;objet est d&amp;rsquo;organiser des programmes complexes grâce aux notions :
 d&amp;rsquo;encapsulation ; d&amp;rsquo;abstraction ; d&amp;rsquo;héritage ; de polymorphisme ;  Remarque : Seules les deux premières notions apparaissent dans le programme de NSI.
Encapsulation Le principe de l&amp;rsquo;encapsulation est de regrouper dans le même objet, les données (attributs) et les traitements (méthodes) qui lui sont spécifiques. Ainsi un objet est défini par ses attributs et ses méthodes.</description>
    </item>
    
    <item>
      <title>Fourniture et utilisation d&#39;une API</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/4-api/</link>
      <pubDate>Tue, 22 Sep 2020 05:15:58 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/4-api/</guid>
      <description>API Une API (en anglais « Application programming interface ») est une interface de programmation d&amp;rsquo;application. Elle est destinée à être utilisée par des programmes. Le principe de ce type d&amp;rsquo;interface est le même que celui des UI (« User Interface ») ou des GUI (« Graphical User Interface ») destinées elles à un utilisateur humain.
Composée de constantes, de fonctions, de classes, elle sert de lien entre un programme et les programmes qui vont l&amp;rsquo;utiliser.</description>
    </item>
    
    <item>
      <title>Paradigmes de programmation</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-3/1-paradigmes-programmation/</link>
      <pubDate>Mon, 21 Sep 2020 20:58:45 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-3/1-paradigmes-programmation/</guid>
      <description>Langages de programmation Un langage de programmation a besoin :
 des règles de grammaire qui définissent la syntaxe des expressions ; d&amp;rsquo;une sémantique qui définit le sens des expressions.   Un langage peut être :
 interprété : un interpréteur lit et analyse le code séquentiellement, le traduit en langage machine et lance son exécution. compilé : un compilateur lit et analyse le code puis le traduit en langage machine.</description>
    </item>
    
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</link>
      <pubDate>Sun, 20 Sep 2020 05:12:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</guid>
      <description>Enquêter sur une erreur dans un calcul de $\pi$ La somme des inverses des carrés des nombres entiers converge vers $\dfrac{\pi^2}{6}$.
$$\sum_{k=1}^{\infty} \dfrac{1}{k^2} = \dfrac{\pi^2}{6}$$
On utilise cette formule pour trouver une approximation de $\pi$. 1 2 3 4 5 6 7 8 9 10 11 12 13  import math def terme(k: int) -&amp;gt; float: return 1 / (k**2) def approxpi(n: int) -&amp;gt; float: s = 0 # utilise les termes jusqu’à 1/n**2 inclus for k in range(n): s = s + terme(k) return math.</description>
    </item>
    
    <item>
      <title>Modules et exceptions</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</link>
      <pubDate>Tue, 15 Sep 2020 05:06:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</guid>
      <description>Ce chapitre se concentre sur les modules de Python et sur les modalités d&amp;rsquo;importation des données des modules dans l&amp;rsquo;environnement de travail.
L&amp;rsquo;objectif de ce document est de souligner l&amp;rsquo;importance d&amp;rsquo;un code modulaire, c&amp;rsquo;est à dire d&amp;rsquo;un code qui :
 puisse être utilisé dans plusieurs programmes ; puisse être documenté précisément ; soit suffisamment compact pour être étudié avec soin et en particulier testé.   Qu&amp;rsquo;est-ce qu&amp;rsquo;un module ?</description>
    </item>
    
    <item>
      <title>Capitalisation d&#39;une valeur</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</link>
      <pubDate>Tue, 15 Sep 2020 05:05:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</guid>
      <description>Cette séance a pour objectif de vous familiariser avec la création et la manipulation de modules.
Comme il est maintenant de tradition vous diviserez le code de votre programme principal en trois parties:
 Importation des modules ; Définitions des fonctions ; Partie principale (lieu d&amp;rsquo;appel des fonctions).  Vous documenterez aussi systématiquement vos fonctions (une aide sera fournie dans les questions relatives à la définition de chacune de ces fonctions).</description>
    </item>
    
    <item>
      <title>Introduction à l&#39;algorithmique, recherche d&#39;un élément dans un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</link>
      <pubDate>Sat, 12 Sep 2020 17:46:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</guid>
      <description>Algorithmique Introduction Un algorithme est une suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser afin de résoudre un problème.  En informatique, pour qu&amp;rsquo;un algorithme puisse être implémenté, il est nécessaire de s&amp;rsquo;assurer que la « suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser » s&amp;rsquo;effectue en une durée finie .
Lorsqu&amp;rsquo;on élabore ou étudie un algorithme, il est donc nécessaire de vérifier :
 Sa finitude : Il doit se terminer en un temps fini.</description>
    </item>
    
    <item>
      <title>Recherche d&#39;un élément dans un tableau&amp;nbsp;: algorithmes itératifs et récursifs</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</link>
      <pubDate>Wed, 09 Sep 2020 21:33:15 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</guid>
      <description>Recherche d&amp;rsquo;un élément dans un tableau La recherche d&amp;rsquo;éléments dans un tableau a déjà été évoquée en classe de première. Les deux algorithmes mis en œuvre à cette occasion, la recherche linéaire et la recherche dichotomique, utilisaient des boucles.
L&amp;rsquo;objectif de cette séance est de rapidement revoir ces algorithmes et de mettre en œuvres des algorithmes récursifs de même complexité. Quatre algorithmes de recherche vont donc être implémentés :
 La recherche linéaire itérative ; La recherche linéaire récursive ; La recherche dichotomique itérative ; La recherche dichotomique récursive.</description>
    </item>
    
    <item>
      <title>La récursivité appliquée aux chaînes de caractères et aux listes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</link>
      <pubDate>Tue, 08 Sep 2020 04:53:31 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</guid>
      <description>Penser à écrire, pour chacune des fonctions ci-dessous, sa spécification ainsi qu&amp;rsquo;un jeu de tests.
Recherche dans une chaîne de caractères Écrire une fonction récursive nommée est_dans, qui, à partir d&amp;rsquo;un caractère e et d&amp;rsquo;une chaîne de caractères c, détermine si ce caractère appartient à la chaîne.
Tester cette fonction.
Remarque : la fonction est_dans est un prédicat.
    Solution  def est_dans(e: str, c: str) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34; Détermine si le caractère e est dans la chaîne c.</description>
    </item>
    
    <item>
      <title>Récursivité sur les entiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</link>
      <pubDate>Sat, 05 Sep 2020 18:34:00 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</guid>
      <description>La récurrence est un raisonnement mathématique courant et parmi les plus puissants pour démontrer des théorèmes ou construire des objets. Par exemple, on l&amp;rsquo;utilise dans un cours de mathématique de lycée pour montrer que :
 Pour tout entier $n \geqslant 0$, on a : $1 + 2 + 3 + \ldots + n = \dfrac{n(n+1)}{2}$ ; Un entier naturel n&amp;rsquo;est autre que 0 ou le successeur d&amp;rsquo;un entier naturel (0 est 0, 1 est le successeur de 0, 2 est le successeur de 1, &amp;hellip;).</description>
    </item>
    
  </channel>
</rss>