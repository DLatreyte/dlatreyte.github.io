<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terminales Spé NSI on Accueil</title>
    <link>https://dlatreyte.github.io/categories/terminales-sp%C3%A9-nsi/</link>
    <description>Recent content in Terminales Spé NSI on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Thu, 21 Jan 2021 06:41:30 +0400</lastBuildDate><atom:link href="https://dlatreyte.github.io/categories/terminales-sp%C3%A9-nsi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Problème du sac à dos</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/5-sac-a-dos/</link>
      <pubDate>Thu, 21 Jan 2021 06:41:30 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/5-sac-a-dos/</guid>
      <description>À lire absolument pour en découvrir plus !  Introduction Dans ce document, on s&amp;rsquo;intéresse à une classe de problèmes d&amp;rsquo;optimisation connus sous le nom général de « problème du sac à dos ». On peut définir ce problème de la manière suivante : « durant un cambriolage un voleur possède un sac dont la capacité (en poids par exemple) est limitée. Il se trouve face à un ensemble d&amp;rsquo;objets qu&amp;rsquo;il veut dérober.</description>
    </item>
    
    <item>
      <title>Exercices de programmation objet</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/6-exercices/</link>
      <pubDate>Wed, 13 Jan 2021 19:12:34 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/6-exercices/</guid>
      <description>Chaque méthode définie devra être accompagnée de sa spécification.  Manipulation de points On considère la classe nommée Point ayant les attributs suivants :
 __abs : attribut privé de type float pour représenter l&amp;rsquo;abscisse du point ; __ord : attribut privé de type float pour représenter l&amp;rsquo;ordonnée du point.   Définir la class Point et le constructeur __init__ permettant d&amp;rsquo;initialiser les deux attributs.  L&#39;encapsulation est un concept fondamental de la conception objet.</description>
    </item>
    
    <item>
      <title>Gestion des processus et des ressources</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-12/3-processus/</link>
      <pubDate>Sun, 10 Jan 2021 05:10:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-12/3-processus/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;essayer de faire comprendre les idées mises en œuvre lors de l&amp;rsquo;écriture des système d&amp;rsquo;exploitation afin qu&#39;un nombre de programmes plus important que le nombre de processeurs puisse fonctionner « simultanément ».
 L&amp;rsquo;ordonnanceur Rappel sur l&amp;rsquo;exécution d&amp;rsquo;un programme   Un programme est un fichier contenant une suite d&amp;rsquo;instructions écrites en langage machine. C&amp;rsquo;est une suite d&amp;rsquo;octets que le processeur que le processeur est capable de décoder et d&amp;rsquo;exécuter.</description>
    </item>
    
    <item>
      <title>Système d&#39;exploitation : Principes généraux</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-12/1-os-principes-generaux/</link>
      <pubDate>Wed, 06 Jan 2021 16:24:21 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-12/1-os-principes-generaux/</guid>
      <description>Introduction  À l&amp;rsquo;aide d&amp;rsquo;un éditeur de texte, écrire le programme Python suivant :  from os.path import getsize from tkinter.filedialog import askopenfilename fichier = askopenfilename() if fichier: print(&amp;#34;Fichier a pour taille {} octets&amp;#34;.format(str(getsize(fichier))))  Exécuter le programme.
  À l&amp;rsquo;aide de la fonction help préciser le rôle des fonctions getsize du module os et askopenfilename du module tkinter.filedialog.
    Réponse   askopenfilename du module tkinter.</description>
    </item>
    
    <item>
      <title>Le routage entre réseaux IP</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-11/5-routage/</link>
      <pubDate>Sat, 02 Jan 2021 15:51:33 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-11/5-routage/</guid>
      <description>Routeurs et objectif du routage ? La responsabilité d’un protocole de routage est de fournir l’information nécessaire pour effectuer un routage, c’est-à-dire la détermination d’un chemin entre une machine émettrice et une machine réceptrice, toutes deux identifiées par leur adresse IP sur des sous-réseaux différents.  Un routeur est un ordinateur possédant au moins deux interfaces réseaux situées sur des sous-réseaux IP différents.  Il faut être capable de distinguer une carte réseau d&amp;rsquo;une interface réseau.</description>
    </item>
    
    <item>
      <title>Système de fichiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-12/2-navigation-systeme-fichiers/</link>
      <pubDate>Wed, 09 Dec 2020 16:15:48 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-12/2-navigation-systeme-fichiers/</guid>
      <description>Linux est un logiciel libre Un logiciel est dit libre si son code est couvert par une licence autorisant :
 l&amp;rsquo;utilisation du logiciel ; l&amp;rsquo;accès public au code source ; la modification et la redistribution publique de ces modifications.   Introduction Il est possible de commander les systèmes d&amp;rsquo;exploitation de la famille UniX et leurs dérivés (tels OS X et Linux) grâce à un logiciel appelé shell, en ligne de commandes.</description>
    </item>
    
    <item>
      <title>Les systèmes d&#39;exploitation</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-12/</link>
      <pubDate>Wed, 09 Dec 2020 10:12:03 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-12/</guid>
      <description>Toute machine est dotée d’un système d’exploitation qui a pour fonction de charger les programmes depuis la mémoire de masse et de lancer leur exécution en leur créant des processus, de gérer l’ensemble des ressources, de traiter les interruptions ainsi que les entrées-sorties et enfin d’assurer la sécurité globale du système.
Au programme de la classe de première    Contenus Capacités attendues Commentaire     Systèmes d’exploitation - Identifier les fonctions d’un système d’exploitation.</description>
    </item>
    
    <item>
      <title>Simulation de réseaux</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-11/4-simulation-reseau/</link>
      <pubDate>Sun, 06 Dec 2020 04:35:41 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-11/4-simulation-reseau/</guid>
      <description>L&amp;rsquo;objectif de cette séance est de mettre en pratique les concepts rappelés lors des séances précédentes et d&amp;rsquo;introduire la notion de routage.
   Télécharger le logiciel Filius
  Choisir le paquet « Zip » pour OSX ou Linux (hors Ubuntu). Pour Windows, on peut choisir « Windows » ou « Zip ».
   Construction d&amp;rsquo;un réseau local   En mode conception, créer le réseau local suivant :   Configurer chaque ordinateur : Mode conception $\longrightarrow$ Clic droit sur l&amp;rsquo;ordinateur $\longrightarrow$ Configurer.</description>
    </item>
    
    <item>
      <title>Analyse du protocole de transport TCP</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-11/3-analyse-tcp/</link>
      <pubDate>Sun, 29 Nov 2020 05:59:52 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-11/3-analyse-tcp/</guid>
      <description>Cette séance nécessite l&amp;rsquo;utilisation du logiciel libre Wireshark. Des versions pour Windows (il existe même une version portable qui n&amp;rsquo;a pas besoin d&amp;rsquo;être installée), OS X et Linux sont téléchargeables à cette adresse : https://www.wireshark.org Fichiers pour utilisation de Wireshark    Rechercher pour quelles actions les protocoles http, pop3, ftp, telnet, ssh et dns sont utilisés.
  Ces protocoles s&amp;rsquo;appuient-ils sur le protocole TCP ou le protocole UDP au niveau de la couche transport du modèle OSI.</description>
    </item>
    
    <item>
      <title>Adressage IP</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-11/2-ip/</link>
      <pubDate>Thu, 26 Nov 2020 06:16:49 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-11/2-ip/</guid>
      <description>L&amp;rsquo;adresse IPv4 d&amp;rsquo;un réseau est 192.168.56.0/24. Combien de bits sont-ils dédiés à la partie réseau ? Combien de machines peut-on incorporer à ce réseau ?    Réponse  24 bits sont réservés au réseau dans l&amp;rsquo;adresse. Une adresse IPv4 étant composée de 32 bits, il reste 8 bits pour l&amp;rsquo;adressage des machines dans ce réseau. Avec ces 8 bits on peut créer $2^8 = 256$ adresses différentes, pour $2^8 - 2 = 254$ ordinateurs.</description>
    </item>
    
    <item>
      <title>Modélisation des réseaux</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-11/1-modelisation-reseaux/</link>
      <pubDate>Thu, 26 Nov 2020 06:13:06 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-11/1-modelisation-reseaux/</guid>
      <description> Rappels de cours au format pdf </description>
    </item>
    
    <item>
      <title>Les tours de Hanoï</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/3-tour-hanoi/</link>
      <pubDate>Tue, 24 Nov 2020 04:54:14 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/3-tour-hanoi/</guid>
      <description>Les tours de Hanoï constituent un problème inventé par le mathématicien français Édouard Lucas. Ce jeu mathématique est constitué de trois tiges sur lesquelles sont enfilés $n$ disques de diamètres différents. Au début du jeu, ces disques sont tous positionnés sur la premiére tige (du plus grand au plus petit) et l’objectif est de déplacer tous ces disques sur la troisième tige, en respectant les règles suivantes :
 Un seul disque peut être déplacé à la fois ; On ne peut jamais poser un disque sur un disque de diamètre inférieur.</description>
    </item>
    
    <item>
      <title>Rotation d&#39;une image bitmap d&#39;un quart de tour</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/2-rotation-image/</link>
      <pubDate>Wed, 18 Nov 2020 17:12:52 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/2-rotation-image/</guid>
      <description>L&amp;rsquo;objectif de cette activité est l&amp;rsquo;écriture d&amp;rsquo;une fonction qui effectue la rotation d&amp;rsquo;une image bitmap de 90 degrés en utilisant le principe « Diviser pour régner ».
On peut manipuler des images en Python à l&amp;rsquo;aide du module PIL (Python Image Library). Une première partie de l&amp;rsquo;activité est consacrée à la prise en main de ce module. Dans un second temps, la fonction de manipulation des bits est développée.
Images numériques Définition L&amp;rsquo;image matricielle Une image matricielle, ou « carte de points » (de l&amp;rsquo;anglais « bitmap »), est une image constituée d&amp;rsquo;une matrice de points colorés, c&amp;rsquo;est-à-dire, constituée d&#39;un tableau, d&amp;rsquo;une grille, où chaque case possède une couleur qui lui est propre et est considérée comme un point.</description>
    </item>
    
    <item>
      <title>Le tri fusion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/1-tri-fusion/</link>
      <pubDate>Wed, 18 Nov 2020 17:12:24 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/1-tri-fusion/</guid>
      <description>La méthode « Diviser pour régner » La méthode « Diviser pour régner » est une méthode de résolution de problèmes qui consiste à décomposer le problème en trois étapes :
  Diviser : Si la taille de l&amp;rsquo;ensemble des données à traiter est inférieure à une certaine limite (un ou deux éléments typiquement) résoudre le problème. Si la taille de l&amp;rsquo;ensemble de données à traiter est supérieur à la limite fixée, diviser cet ensemble en deux sous-ensembles (de tailles inférieures).</description>
    </item>
    
    <item>
      <title>Le codage d&#39;Huffman</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/4-codage-huffman/</link>
      <pubDate>Mon, 16 Nov 2020 16:11:14 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/4-codage-huffman/</guid>
      <description>Cette séance a pour objet l&amp;rsquo;étude d&amp;rsquo;une méthode de compression de données inventée par David Albert Huffman en 1952. Cette méthode permet de réduire la longueur du codage d’un alphabet et repose sur la création d’un arbre binaire.
 Différents types de codages On appelle alphabet l’ensemble des symboles (caractères) composant la donnée de départ à compresser.  Dans la suite, nous utiliserons un alphabet composé seulement des 8 lettres A, B, C, D, E, F, G et H.</description>
    </item>
    
    <item>
      <title>Arbres Binaires Recherche</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/3-arbres-binaires-recherche/</link>
      <pubDate>Tue, 10 Nov 2020 05:04:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/3-arbres-binaires-recherche/</guid>
      <description>Introduction Une utilisation particulière des arbres binaires est la notion d’arbre binaire de recherche. On suppose que les valeurs des nœuds sont des objets comparables entre eux : pour fixer les idées, on considère n’avoir que des entiers.
Un arbre binaire de recherche, ou ABR, est un arbre binaire avec la propriété suivante : pour tout nœud $x$, tous les nœuds situés dans le sous-arbre gauche de $x$ ont une valeur $\leqslant val(x)$, et tous ceux situés dans son sous-arbre droit ont une valeur $\geqslant val(x)$.</description>
    </item>
    
    <item>
      <title>Les arbres binaires</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/2-arbres-binaires/</link>
      <pubDate>Thu, 05 Nov 2020 03:38:41 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/2-arbres-binaires/</guid>
      <description>Le corrigé de l&amp;rsquo;activité se trouve ici  Arbres binaires Définition   Un arbre binaire est un arbre de degré 2 (dont les nœuds sont au plus de degré 2).
  Les enfants d’un nœud sont lus de gauche à droite et sont appelés : fils gauche et fils droit.
   Pour simplifier la présentation, on va considérer que chaque nœud possède exactement deux fils mais que ceux-ci peuvent être vides (None par exemple).</description>
    </item>
    
    <item>
      <title>Structures de données abstraites arborescentes : les arbres</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-9/1-introduction-arbres/</link>
      <pubDate>Thu, 05 Nov 2020 03:37:56 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-9/1-introduction-arbres/</guid>
      <description>La notion de listes chaînées est parfaite pour structurer un ensemble d&amp;rsquo;élements destinés à être énumérés séquentiellement. Elle permet aussi d&amp;rsquo;implémenter les structures de piles et de files. Elle n&amp;rsquo;est cependant pas adaptée aux accès spécifiques à des positions données dans la séquence, puisqu&amp;rsquo;il faut alors parcourir toutes les cellules depuis le début de la liste jusqu&amp;rsquo;à la position souhaitée (complexité en $O(N)$).
 Document de référence pour ce cours Structures arborescentes Lorsqu&amp;rsquo;on manipule une information présentant une certaine hiérarchie, il est commun de la représenter graphiquement :</description>
    </item>
    
    <item>
      <title>Les Files</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-8/2-files/</link>
      <pubDate>Sat, 31 Oct 2020 22:50:06 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-8/2-files/</guid>
      <description>Rappel : Type de Données Abstrait (TDA) Une structure de données ou type de données abstrait est un moyen d&amp;rsquo;organiser et de manipuler les données en mémoire. Un TDA est donc définit par :
 Son nom ; Sa spécification, c&amp;rsquo;est à dire la liste des manipulations/opérations que l&amp;rsquo;on peut ou pas effectuer.
La spécification indique généralement la complexité de chacune des opérations prévues par le TDA.  Un type de données abstrait ne dépend pas de la manière dont la structure de données est implémentée dans le langage de programmation utilisé.</description>
    </item>
    
    <item>
      <title>Les Piles</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-8/1-piles/</link>
      <pubDate>Tue, 27 Oct 2020 03:40:03 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-8/1-piles/</guid>
      <description>Rappel : Type de Données Abstrait (TDA) Une structure de données ou type de données abstrait est un moyen d&amp;rsquo;organiser et de manipuler les données en mémoire. Un TDA est donc définit par :
 Son nom ; Sa spécification, c&amp;rsquo;est à dire la liste des manipulations/opérations que l&amp;rsquo;on peut ou pas effectuer.
La spécification indique généralement la complexité de chacune des opérations prévues par le TDA.  Un type de données abstrait ne dépend pas de la manière dont la structure de données est implémentée dans le langage de programmation utilisé.</description>
    </item>
    
    <item>
      <title>Listes Chaînées</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-7/1-listes-chainees/</link>
      <pubDate>Wed, 14 Oct 2020 18:01:18 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-7/1-listes-chainees/</guid>
      <description>Un corrigé de la section 1 se trouve ici
  Un corrigé des sections suivantes se trouve ici
   Tableaux  Un tableau est une structure de données dans laquelle les éléments, de même type, occupent des positions contiguës en mémoire. Le nombre d&amp;rsquo;éléments qu&amp;rsquo;un tableau peut contenir est déterminé à la création d&amp;rsquo;un tableau.      Type Python Type abstrait Opération Exemple Complexité     N&amp;rsquo;existe pas Tableau Accès à un élément tab[i] $O(1)$     Modification d&amp;rsquo;un élément tab[i] = x $O(1)$     Effacement d&amp;rsquo;un élément retire(tab, i) $O(n)$     Insertion d&amp;rsquo;un élément insere(tab, x, i) $O(n)$     Recherche d&amp;rsquo;un élément est_dans(tab, x) $O(n)$     La structure de données appelée « liste » dans le langage Python est en fait un tableau dynamique.</description>
    </item>
    
    <item>
      <title>Structures de données fournies avec le langage Python</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/1-structures-integrees/</link>
      <pubDate>Tue, 13 Oct 2020 05:25:49 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/1-structures-integrees/</guid>
      <description>Python possède dans la bibliothèque standard un grand nombre de structures de données, programmées de manière efficace.
Pourquoi différentes structures de données ? Les structures de données organisent différemment les données que le programme traite. Le langage Python fournissant le type list, on pourrait se demander pourquoi ne pas systématiquement l&amp;rsquo;utiliser et pourquoi devoir apprendre de nouveaux types.
En fait, la spécialisation des structures de données rend la programmation plus simple (utilisation de l&#39;API) et plus efficace (complexité).</description>
    </item>
    
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/2-exercices/</link>
      <pubDate>Tue, 13 Oct 2020 05:08:27 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/2-exercices/</guid>
      <description>Itérer sur les éléments d&amp;rsquo;un dictionnaire Au zoo de Beauval, il y a 5 éléphants d&amp;rsquo;Asie, 17 écureuils d&amp;rsquo;Asie, 2 pandas d&amp;rsquo;Asie, etc. On représente cet inventaire à l&amp;rsquo;aide d&amp;rsquo;un dictionnaire, de façon suivante :
zoo_Beauval={ &amp;#39;éléphant&amp;#39;: (&amp;#39;Asie&amp;#39;, 5), &amp;#39;écureuil&amp;#39;: (&amp;#39;Asie&amp;#39;, 17), &amp;#39;panda&amp;#39;: (&amp;#39;Asie&amp;#39;, 2), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 4) } On représente de la même façon le zoo de La Flèche :
zoo_LaFleche = { &amp;#39;ours&amp;#39;: (&amp;#39;Europe&amp;#39;, 4), &amp;#39;tigre&amp;#39;: (&amp;#39;Asie&amp;#39;, 7), &amp;#39;girafe&amp;#39;: (&amp;#39;Afrique&amp;#39;, 11), &amp;#39;hippopotame&amp;#39;: (&amp;#39;Afrique&amp;#39;, 3) } On souhaite se doter d&amp;rsquo;une fonction plus_grand_nombre() qui prend un zoo en paramètre et qui renvoie le nom de l&amp;rsquo;animal le plus représenté dans ce zoo.</description>
    </item>
    
    <item>
      <title>Modéliser les notes des élèves</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-6/3-annale/</link>
      <pubDate>Tue, 13 Oct 2020 05:06:51 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-6/3-annale/</guid>
      <description>Partie 1 : Modélisation simpliste On modélise les notes d&amp;rsquo;une élève de la faon suivante :
notes_de_lea = [12, 14, 3, 16, 17, 2, 13, 19]  Quel est le type de notes_de_lea ?  un int une liste un tuple un dictionnaire autre chose   Que vaut l&amp;rsquo;expression notes_de_lea[2] ?  3 14 6 5 autre chose   Quelle instruction permet d&amp;rsquo;ajouter une note de 15 à cette structure de données ?</description>
    </item>
    
    <item>
      <title>Tri par insertion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-5/2-tri-insertion/</link>
      <pubDate>Wed, 07 Oct 2020 21:53:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-5/2-tri-insertion/</guid>
      <description>Objectifs  Le tri par insertion a été étudié en classe de 1ère. Dans ce document, après un rappel du cours de 1ère, nous allons implémenter une version récursive de cet algorithme et ensuite utiliser la possibilité que les fonctions en Python ont d&amp;rsquo;accepter des fonctions comme paramètres, afin de rendre plus générale et utile cette fonction de tri.
 Tri du joueur de cartes Le tri par insertion est un tri « naturel » souvent qualifié de « tri du joueur de carte ».</description>
    </item>
    
    <item>
      <title>Programmation Fonctionnelle</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-5/1-programmation-fonctionnelle/</link>
      <pubDate>Tue, 06 Oct 2020 03:49:30 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-5/1-programmation-fonctionnelle/</guid>
      <description>Qu&amp;rsquo;est-ce que la programmation fonctionnelle ? S&amp;rsquo;il n&amp;rsquo;est pas facile de répondre précisément à cette question, on peut essayer de mettre en évidence les idées que le paradigme fonctionnel promeut :
  Les fonctions doivent être des objets de première classe, c&amp;rsquo;est à dire que les fonctions doivent pouvoir être passées comme arguments à une fonction, les fonctions doivent aussi pouvoir être retournées par une fonction.
  Les fonctions doivent (le plus possible) être pures, c&amp;rsquo;est à dire ne générer aucun effet de bord.</description>
    </item>
    
    <item>
      <title>Jeu de la vie</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/5-jeu-vie/</link>
      <pubDate>Sun, 04 Oct 2020 04:35:40 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/5-jeu-vie/</guid>
      <description>Le but de ce sujet est de réaliser en Python une implémentation du jeu de la vie en utilisant la programmation objet.
 Le jeu de la vie a été inventé par le mathématicien britannique John H. Conway (1937-2020). C’est un exemple de ce qu’on appelle un automate cellulaire. Il se déroule sur un tableau rectangulaire $(L \times H)$ de cellules. Une cellule est représentée par ses coordonnées $x$ et $y$ qui vérifient $0 \leqslant x &amp;lt; L$ et $0 \leqslant y &amp;lt; H$.</description>
    </item>
    
    <item>
      <title>Résoudre un problème grâce aux paradigmes objet et fonctionnel</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/4-fonction/</link>
      <pubDate>Thu, 01 Oct 2020 04:21:17 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/4-fonction/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;illustrer une fois encore l&amp;rsquo;intérêt des différents paradigmes de programmation.
Cas d&amp;rsquo;étude : fonction avec paramètres On considère l&amp;rsquo;équation qui traduit le mouvement d&amp;rsquo;une balle lancée verticalement vers le haut avec une vitesse $\vec{v}_0$ depuis l&amp;rsquo;origine des altitudes telle que l&amp;rsquo;écrit un physicien : $$y(t) = -\dfrac{1}{2}g\, t^2 + v_0\, t$$ Ce physicien a donc tendance à considérer que $y$ est une fonction de la variable $t$ et que cette fonction dépend des paramètres $v_0$ et $g$.</description>
    </item>
    
    <item>
      <title>Méthodes spéciales</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/3-exercices/</link>
      <pubDate>Tue, 29 Sep 2020 09:51:52 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/3-exercices/</guid>
      <description>Définit une classe nommée Fraction pour représenter les nombres rationnels. Cette classe doit posséder deux attributs num et denom, de type entier, qui représentent respectivement le numérateur et le dénominateur du nombre rationnel.
On demande que le dénominateur soit un entier positif.
Un corrigé de cette activité se trouve à cette adresse : https://repl.it/@dlatreyte/fraction   Écrire le constructeur de cette classe. Une exception de type ValueError doit être levée si le dénominateur n&amp;rsquo;est pas un nombre entier positif.</description>
    </item>
    
    <item>
      <title>Simulation du fonctionnement d&#39;une banque</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/2-banque/</link>
      <pubDate>Sat, 26 Sep 2020 20:06:58 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/2-banque/</guid>
      <description>L&amp;rsquo;objectif de ce document est de simuler (sommairement bien sûr) le fonctionnement d&amp;rsquo;une banque. Le programme doit permettre :
 La création d&amp;rsquo;une banque ; La création de comptes bancaires ; La création de personnes propriétaires de ces comptes bancaires.  Une correction se trouve à cette adresse : https://repl.it/@dlatreyte/banque Classe Personne Dans un module nommé personne, créer la classe Personne dont la spécification est la suivante :
class Personne(): &amp;#34;&amp;#34;&amp;#34; Modélisation d&amp;#39;une personne.</description>
    </item>
    
    <item>
      <title>Programmation Objet</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-4/1-programmation-objet/</link>
      <pubDate>Wed, 23 Sep 2020 21:07:12 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-4/1-programmation-objet/</guid>
      <description>Programmation orientée objet L&amp;rsquo;un des objectifs principaux de la notion d&amp;rsquo;objet est d&amp;rsquo;organiser des programmes complexes grâce aux notions :
 d&#39;encapsulation ; d&#39;abstraction ; d&#39;héritage ; de polymorphisme ;  Remarque : Seules les deux premières notions apparaissent dans le programme de NSI.
Encapsulation Le principe de l&amp;rsquo;encapsulation est de regrouper dans le même objet, les données (attributs) et les traitements (méthodes) qui lui sont spécifiques. Ainsi un objet est défini par ses attributs et ses méthodes.</description>
    </item>
    
    <item>
      <title>Fourniture et utilisation d&#39;une API</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/4-api/</link>
      <pubDate>Tue, 22 Sep 2020 05:15:58 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/4-api/</guid>
      <description>API Une API (en anglais « Application programming interface ») est une interface de programmation d&amp;rsquo;application. Elle est destinée à être utilisée par des programmes. Le principe de ce type d&amp;rsquo;interface est le même que celui des UI (« User Interface ») ou des GUI (« Graphical User Interface ») destinées elles à un utilisateur humain.
Composée de constantes, de fonctions, de classes, elle sert de lien entre un programme et les programmes qui vont l&amp;rsquo;utiliser.</description>
    </item>
    
    <item>
      <title>Paradigmes de programmation</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-3/1-paradigmes-programmation/</link>
      <pubDate>Mon, 21 Sep 2020 20:58:45 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-3/1-paradigmes-programmation/</guid>
      <description>Langages de programmation Un langage de programmation a besoin :
 des règles de grammaire qui définissent la syntaxe des expressions ; d&amp;rsquo;une sémantique qui définit le sens des expressions.   Un langage peut être :
 interprété : un interpréteur lit et analyse le code séquentiellement, le traduit en langage machine et lance son exécution. compilé : un compilateur lit et analyse le code puis le traduit en langage machine.</description>
    </item>
    
    <item>
      <title>Exercices</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</link>
      <pubDate>Sun, 20 Sep 2020 05:12:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/3-exercices/</guid>
      <description>Enquêter sur une erreur dans un calcul de $\pi$ La somme des inverses des carrés des nombres entiers converge vers $\dfrac{\pi^2}{6}$.
$$\sum_{k=1}^{\infty} \dfrac{1}{k^2} = \dfrac{\pi^2}{6}$$
On utilise cette formule pour trouver une approximation de $\pi$. 1 2 3 4 5 6 7 8 9 10 11 12 13  import math def terme(k: int) -&amp;gt; float: return 1 / (k**2) def approxpi(n: int) -&amp;gt; float: s = 0 # utilise les termes jusqu’à 1/n**2 inclus for k in range(n): s = s + terme(k) return math.</description>
    </item>
    
    <item>
      <title>Modules et exceptions</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</link>
      <pubDate>Tue, 15 Sep 2020 05:06:32 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/1-modules/</guid>
      <description>Ce chapitre se concentre sur les modules de Python et sur les modalités d&amp;rsquo;importation des données des modules dans l&amp;rsquo;environnement de travail.
L&amp;rsquo;objectif de ce document est de souligner l&amp;rsquo;importance d&amp;rsquo;un code modulaire, c&amp;rsquo;est à dire d&amp;rsquo;un code qui :
 puisse être utilisé dans plusieurs programmes ; puisse être documenté précisément ; soit suffisamment compact pour être étudié avec soin et en particulier testé.   Qu&amp;rsquo;est-ce qu&amp;rsquo;un module ?</description>
    </item>
    
    <item>
      <title>Capitalisation d&#39;une valeur</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</link>
      <pubDate>Tue, 15 Sep 2020 05:05:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-2/2-capitalisation/</guid>
      <description>Cette séance a pour objectif de vous familiariser avec la création et la manipulation de modules.
Comme il est maintenant de tradition vous diviserez le code de votre programme principal en trois parties:
 Importation des modules ; Définitions des fonctions ; Partie principale (lieu d&amp;rsquo;appel des fonctions).  Vous documenterez aussi systématiquement vos fonctions (une aide sera fournie dans les questions relatives à la définition de chacune de ces fonctions).</description>
    </item>
    
    <item>
      <title>Introduction à l&#39;algorithmique, recherche d&#39;un élément dans un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</link>
      <pubDate>Sat, 12 Sep 2020 17:46:07 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-4-rappels-algorithmique/</guid>
      <description>Algorithmique Introduction Un algorithme est une suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser afin de résoudre un problème.  En informatique, pour qu&amp;rsquo;un algorithme puisse être implémenté, il est nécessaire de s&amp;rsquo;assurer que la « suite finie et non ambiguë d&amp;rsquo;opérations ou d&amp;rsquo;instructions à réaliser » s&amp;rsquo;effectue en une durée finie .
Lorsqu&amp;rsquo;on élabore ou étudie un algorithme, il est donc nécessaire de vérifier :
 Sa finitude : Il doit se terminer en un temps fini.</description>
    </item>
    
    <item>
      <title>Recherche d&#39;un élément dans un tableau&amp;nbsp;: algorithmes itératifs et récursifs</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</link>
      <pubDate>Wed, 09 Sep 2020 21:33:15 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-3-recursivite-recherches/</guid>
      <description>Recherche d&amp;rsquo;un élément dans un tableau La recherche d&amp;rsquo;éléments dans un tableau a déjà été évoquée en classe de première. Les deux algorithmes mis en œuvre à cette occasion, la recherche linéaire et la recherche dichotomique, utilisaient des boucles.
L&amp;rsquo;objectif de cette séance est de rapidement revoir ces algorithmes et de mettre en œuvres des algorithmes récursifs de même complexité. Quatre algorithmes de recherche vont donc être implémentés :
 La recherche linéaire itérative ; La recherche linéaire récursive ; La recherche dichotomique itérative ; La recherche dichotomique récursive.</description>
    </item>
    
    <item>
      <title>La récursivité appliquée aux chaînes de caractères et aux listes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</link>
      <pubDate>Tue, 08 Sep 2020 04:53:31 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-2-recursivite-chaines-listes/</guid>
      <description>Penser à écrire, pour chacune des fonctions ci-dessous, sa spécification ainsi qu&amp;rsquo;un jeu de tests.
Recherche dans une chaîne de caractères Écrire une fonction récursive nommée est_dans, qui, à partir d&amp;rsquo;un caractère e et d&amp;rsquo;une chaîne de caractères c, détermine si ce caractère appartient à la chaîne.
Tester cette fonction.
Remarque : la fonction est_dans est un prédicat.
   Solution  def est_dans(e: str, c: str) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34; Détermine si le caractère e est dans la chaîne c.</description>
    </item>
    
    <item>
      <title>Récursivité sur les entiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</link>
      <pubDate>Sat, 05 Sep 2020 18:34:00 +0400</pubDate>
      <author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-1/1-1-recursivite-sur-entiers/</guid>
      <description>La récurrence est un raisonnement mathématique courant et parmi les plus puissants pour démontrer des théorèmes ou construire des objets. Par exemple, on l&amp;rsquo;utilise dans un cours de mathématique de lycée pour montrer que :
 Pour tout entier $n \geqslant 0$, on a : $1 + 2 + 3 + \ldots + n = \dfrac{n(n+1)}{2}$ ; Un entier naturel n&amp;rsquo;est autre que 0 ou le successeur d&amp;rsquo;un entier naturel (0 est 0, 1 est le successeur de 0, 2 est le successeur de 1, &amp;hellip;).</description>
    </item>
    
  </channel>
</rss>
