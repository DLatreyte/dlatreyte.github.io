<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fonctions on Accueil</title>
    <link>https://dlatreyte.github.io/tags/fonctions/</link>
    <description>Recent content in Fonctions on Accueil</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Sun, 29 Aug 2021 16:36:24 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/tags/fonctions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tester ses fonctions avec &#39;assert&#39;</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-05/2-assert/</link>
      <pubDate>Sun, 29 Aug 2021 16:36:24 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-05/2-assert/</guid>
      <description>Dans le document 5,1, nous avons insisté sur l&amp;rsquo;importance de la spécification d&amp;rsquo;une fonction et sur celle d&amp;rsquo;un jeu de tests.&#xA;Dans ce document, nous allons découvrir une nouvelle façon de tester ses fonctions.&#xA;Le mot clé assert Le mot clé assert est utilisé afin de s&amp;rsquo;assurer de la robustesse d&amp;rsquo;une fonction. Il ne doit jamais être utilisé au sein d&amp;rsquo;un programme pour lever une exception ; il ne faut donc pas le confondre avec le mot clé raise.</description>
    </item>
    <item>
      <title>Récursivité sur les entiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-1-recursivite-sur-entiers/</link>
      <pubDate>Sat, 05 Sep 2020 18:34:00 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-1-recursivite-sur-entiers/</guid>
      <description>To understand recursion, you must first understand recursion. La récurrence est un raisonnement mathématique courant et parmi les plus puissants pour démontrer des théorèmes ou construire des objets. Par exemple, on l&amp;rsquo;utilise dans un cours de mathématique de lycée pour montrer que :&#xA;Pour tout entier $n \geqslant 0$, on a : $1 + 2 + 3 + \ldots + n = \dfrac{n(n+1)}{2}$ ; Un entier naturel n&amp;rsquo;est autre que 0 ou le successeur d&amp;rsquo;un entier naturel (0 est 0, 1 est le successeur de 0, 2 est le successeur de 1, &amp;hellip;).</description>
    </item>
    <item>
      <title>Langages et programmation</title>
      <link>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</link>
      <pubDate>Sat, 14 Sep 2019 21:37:45 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/premieres-nsi/chap-02/chap-02/</guid>
      <description>À quoi a-t-on accès lorsqu&amp;rsquo;on utilise un langage de programmation ? Un langage de programmation doit :&#xA;fournir des objets (ou types) primitifs ; posséder une bibliothèque de fonctions prédéfinies ; permettre la manipulation des objets primitifs et des fonctions prédéfinies ; établir des règles qui permettent de construire de nouveaux objets (ou types) ou de nouvelles fonctions par combinaison des types primitifs et des fonctions prédéfinies. Nous allons aborder chacun de ces points.</description>
    </item>
  </channel>
</rss>
