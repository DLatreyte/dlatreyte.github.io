<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Récursivité on Accueil</title>
    <link>https://dlatreyte.github.io/tags/r%C3%A9cursivit%C3%A9/</link>
    <description>Recent content in Récursivité on Accueil</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <lastBuildDate>Sun, 29 Jan 2023 23:13:31 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/tags/r%C3%A9cursivit%C3%A9/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Somme des $n$ nombres d&#39;un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/7-somme-nombres/</link>
      <pubDate>Sun, 29 Jan 2023 23:13:31 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/7-somme-nombres/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;L’objectif de ce document est d’écrire et d’implémenter un algorithme s’appuyant sur le raisonnement « Diviser pour régner » qui permet de déterminer la somme des $n$ nombres (entiers) d&amp;rsquo;un tableau.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Écrire le code de fonction &lt;code&gt;somme1&lt;/code&gt; dont la spécification est :&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;somme1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Calcul de la somme des nombres éléments&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    de tab.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Algorithme : Récursivité enveloppée&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Penser à écrire un jeu de tests.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Autour de la suite de Fibonacci</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/1-suite-fibonacci/</link>
      <pubDate>Thu, 25 Feb 2021 04:49:20 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/1-suite-fibonacci/</guid>
      <description>&lt;h2 id=&#34;rappel--récursivité-terminale&#34;&gt;Rappel : récursivité terminale&lt;/h2&gt;&#xA;&lt;p&gt;La définition de la fonction factorielle est&#xA;$$&#xA;n! =&#xA;\begin{cases}&#xA;1 &amp;amp; \text{if } n = 0 \cr&#xA;n \times (n-1)! &amp;amp; \text{sinon}&#xA;\end{cases}&#xA;$$&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Définir la fonction &lt;code&gt;fact_env&lt;/code&gt; qui calcule la factorielle d&amp;rsquo;un entier naturel $n$, &lt;em&gt;sans oublier le jeu de tests&lt;/em&gt;.&lt;br&gt;&#xA;La spécification de la fonction est :&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Retourne la factorielle de n.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Algorithme : récursivité enveloppée&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr /&gt;&#xA;&lt;details style=&#34;background-color: #f2f2f2;&#34;&gt;&#xA;    &lt;summary&gt;&#xA;        &lt;strong&gt; Réponse&lt;/strong&gt;&#xA;    &lt;/summary&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Retourne la factorielle de n.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Algorithme : récursivité enveloppée&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;120&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;40320&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;/details&gt;&#xA;&lt;hr /&gt;&#xA;&lt;div class=&#34;note normal&#34;&gt;&#xA;  &lt;p&gt;En informatique, la &lt;strong&gt;récursion terminale&lt;/strong&gt;, aussi appelée, récursion finale, est un &lt;em&gt;cas particulier de récursivité assimilée à une itération&lt;/em&gt;.&lt;br&gt;&#xA;Une fonction à récursivité terminale (dite tail-recursive en anglais) est une fonction où l&amp;rsquo;&lt;strong&gt;appel récursif est la dernière instruction à être évaluée&lt;/strong&gt;. Cette instruction est alors nécessairement « pure », c&amp;rsquo;est-à-dire qu&amp;rsquo;elle consiste en un simple appel à la fonction, et jamais à un calcul ou une composition.&lt;br&gt;&#xA;Les algorithmes récursifs exprimés à l&amp;rsquo;aide de fonctions à récursion terminale profitent donc d&amp;rsquo;une optimisation de la pile d&amp;rsquo;exécution.&lt;br&gt;&#xA;Cette réorganisation économise de l&amp;rsquo;espace mémoire car aucun état, sauf l&amp;rsquo;adresse de la fonction appelante, n&amp;rsquo;a besoin d&amp;rsquo;être sauvé sur la pile d&amp;rsquo;exécution. Cela signifie également que le programmeur n&amp;rsquo;a pas à craindre l&amp;rsquo;épuisement de l&amp;rsquo;espace de pile ou du tas pour des récursions très profondes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dessin de figures fractales</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/5-fractales/</link>
      <pubDate>Tue, 26 Jan 2021 06:16:46 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/5-fractales/</guid>
      <description>&lt;div class=&#34;note tip&#34;&gt;&#xA;  &lt;p&gt;Le mot fractale vient du latin fractus qui signifie brisé. En effet, une&#xA;figure fractale est un objet géométrique infiniment morcelé des détails&#xA;sont observables à une échelle arbitrairement choisie.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;En zoomant sur une partie de la figure, on peut retrouver toute la&#xA;figure&lt;/em&gt;, on dit qu&amp;rsquo;elle est &lt;strong&gt;auto similaire&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;remote&#34; href=&#34;&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.maths-et-tiques.fr/index.php/detentes/les-fractales&#34;&gt;http://www.maths-et-tiques.fr/index.php/detentes/les-fractales&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;remote&#34; href=&#34;&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://fr.wikipedia.org/wiki/Fractalehttp://fr.wikipedia.org/wiki/Fractale&#34;&gt;http://fr.wikipedia.org/wiki/Fractalehttp://fr.wikipedia.org/wiki/Fractale&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Dans le code suivant (qu&amp;rsquo;il faudra étudier et exécuter) :&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Quel est le cas de base de l&amp;rsquo;algorithme récursif ?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Les tours de Hanoï</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/3-tour-hanoi/</link>
      <pubDate>Tue, 24 Nov 2020 04:54:14 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/3-tour-hanoi/</guid>
      <description>&lt;div class=&#34;note normal&#34;&gt;&#xA;  &lt;p&gt;Le problème mathématique des tours de Hanoï a été inventé par Édouard Lucas. Paru d&amp;rsquo;abord en fascicule en 1889 , il est publié ensuite dans le tome 3 de ses « Récréations mathématiques », parues à titre posthume en 1892. Il annonce que ce problème est dû à un de ses amis, N. Claus de Siam (anagramme de Lucas d&amp;rsquo;Amiens, Amiens étant sa ville de naissance), prétendument professeur au collège de Li-Sou-Stian (anagramme de Saint Louis, le lycée où Lucas enseignait).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rotation d&#39;une image bitmap d&#39;un quart de tour</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/6-rotation-image/</link>
      <pubDate>Wed, 18 Nov 2020 17:12:52 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/6-rotation-image/</guid>
      <description>&lt;p&gt;L&amp;rsquo;objectif de cette activité est l&amp;rsquo;écriture d&amp;rsquo;une fonction qui effectue la rotation d&amp;rsquo;une image bitmap de 90 degrés en utilisant le principe « Diviser pour régner ».&lt;/p&gt;&#xA;&lt;p&gt;On peut manipuler des images en Python à l&amp;rsquo;aide du &lt;strong&gt;module PIL (Python Image Library)&lt;/strong&gt;. Une première partie de l&amp;rsquo;activité est consacrée à la prise en main de ce module. Dans un second temps, la fonction de manipulation des bits est développée.&lt;/p&gt;&#xA;&lt;h2 id=&#34;images-numériques&#34;&gt;Images numériques&lt;/h2&gt;&#xA;&lt;h3 id=&#34;définition&#34;&gt;Définition&lt;/h3&gt;&#xA;&lt;div class=&#34;note normal&#34;&gt;&#xA;  &lt;h4 id=&#34;limage-matricielle&#34;&gt;L&amp;rsquo;image matricielle&lt;/h4&gt;&#xA;&lt;p&gt;Une &lt;strong&gt;image matricielle&lt;/strong&gt;, ou « carte de points » (de l&amp;rsquo;anglais « bitmap »), est une image constituée d&amp;rsquo;une &lt;em&gt;matrice de points colorés&lt;/em&gt;, c&amp;rsquo;est-à-dire, constituée d&amp;rsquo;&lt;em&gt;un tableau, d&amp;rsquo;une grille, où chaque case possède une couleur qui lui est propre et est considérée comme un point&lt;/em&gt;. Il s&amp;rsquo;agit donc d&amp;rsquo;une juxtaposition de points de couleurs formant, dans leur ensemble, une image.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tri par insertion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/2-tri-insertion/</link>
      <pubDate>Wed, 07 Oct 2020 21:53:32 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/2-tri-insertion/</guid>
      <description>&lt;h2 id=&#34;objectifs&#34;&gt;Objectifs&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Le tri par insertion a été étudié en classe de 1ère. Dans ce document, après un rappel du cours de 1ère, nous allons implémenter une &lt;em&gt;version récursive&lt;/em&gt; de cet algorithme et ensuite utiliser la possibilité que les fonctions en Python ont d&amp;rsquo;accepter des fonctions comme paramètres, afin de &lt;em&gt;rendre plus générale et utile&lt;/em&gt; cette fonction de tri.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;tri-du-joueur-de-cartes&#34;&gt;Tri du joueur de cartes&lt;/h2&gt;&#xA;&lt;img src=&#34;../../terminales-nsi/chap-5/chap-5-2-1.jpg&#34; alt=&#34;&#34; width=&#34;40%&#34; style=&#34;float: right;&#34; /&gt;&#xA;Le tri par insertion est un tri « naturel » souvent qualifié de « tri du joueur de carte ». Comment un joueur de carte fait-il pour trier les cartes ?&#xA;-  Au début, la main gauche du joueur est vide et ses cartes sont posées sur la table.&#xA;-  Le joueur prend alors sur la table les cartes, une par une avec sa main droite, pour les placer dans sa main gauche.&#xA;-  Pour savoir où placer une carte dans son jeu, le joueur la compare avec chacune des cartes déjà présentes dans sa main gauche, *en examinant les cartes de la droite vers la gauche*.&#xA;-  *À tout moment, les cartes tenues par la main gauche sont triées* ; ces cartes étaient, à l&#39;origine, les cartes situées au sommet de la pile sur la table. &#xA;&lt;h2 id=&#34;tri-par-insertion&#34;&gt;Tri par insertion&lt;/h2&gt;&#xA;&lt;div class=&#34;note warning&#34;&gt;&#xA;  Une correction du code à développer ci-dessous se trouve&#xA;&lt;a class=&#34;remote&#34; href=&#34;https://repl.it/@dlatreyte/triparinsertion&#34; target=&#34;_blank&#34;&gt;ici&lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;La méthode du tri par insertion est ilustré à &#xA;&lt;a class=&#34;remote&#34; href=&#34;https://youtu.be/K4CuPzdiAIo&#34; target=&#34;_blank&#34;&gt;ici&lt;/a&gt;&#xA;&#xA;, ou, de façon plus folklorique, &#xA;&lt;a class=&#34;remote&#34; href=&#34;https://youtu.be/ROalU379l3U&#34; target=&#34;_blank&#34;&gt;ici&lt;/a&gt;&#xA;&#xA;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Programmation Fonctionnelle</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/1-programmation-fonctionnelle/</link>
      <pubDate>Tue, 06 Oct 2020 03:49:30 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-fonctionnelle/1-programmation-fonctionnelle/</guid>
      <description>&lt;h2 id=&#34;quest-ce-que-la-programmation-fonctionnellenbsp&#34;&gt;Qu&amp;rsquo;est-ce que la programmation fonctionnelle ?&lt;/h2&gt;&#xA;&lt;p&gt;S&amp;rsquo;il n&amp;rsquo;est pas facile de répondre précisément à cette question, on peut essayer de mettre en évidence les idées que le paradigme fonctionnel promeut :&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Les fonctions doivent être des &lt;strong&gt;objets de première classe&lt;/strong&gt;, c&amp;rsquo;est à dire que &lt;em&gt;les fonctions doivent pouvoir être passées comme arguments à une fonction, les fonctions doivent aussi pouvoir être retournées par une fonction&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Les fonctions doivent (le plus possible) être &lt;strong&gt;pures&lt;/strong&gt;, c&amp;rsquo;est à dire ne &lt;em&gt;générer aucun effet de bord&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Recherche d&#39;un élément dans un tableau : algorithmes itératifs et récursifs</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-3-recursivite-recherches/</link>
      <pubDate>Wed, 09 Sep 2020 21:33:15 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-3-recursivite-recherches/</guid>
      <description>&lt;h2 id=&#34;recherche-dun-élément-dans-un-tableau&#34;&gt;Recherche d&amp;rsquo;un élément dans un tableau&lt;/h2&gt;&#xA;&lt;p&gt;La recherche d&amp;rsquo;éléments dans un tableau a déjà été évoquée en classe de première. Les deux algorithmes mis en œuvre à cette occasion, la &lt;strong&gt;recherche linéaire&lt;/strong&gt; et la &lt;strong&gt;recherche dichotomique&lt;/strong&gt;, utilisaient des boucles.&lt;br&gt;&#xA;L&amp;rsquo;objectif de cette séance est de rapidement revoir ces algorithmes et de mettre en œuvres des algorithmes récursifs de même complexité. Quatre algorithmes de recherche vont donc être implémentés :&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;La recherche linéaire itérative&lt;/em&gt; ;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;La recherche linéaire récursive&lt;/em&gt; ;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;La recherche dichotomique itérative&lt;/em&gt; ;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;La recherche dichotomique récursive&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;travail-à-faire&#34;&gt;Travail à faire&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Implémenter en Python les cinq algorithmes suivants et répondre aux questions.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;note warning&#34;&gt;&#xA;  Penser à donner la &lt;strong&gt;spécification&lt;/strong&gt; de chacune des fonctions et écrire une &lt;strong&gt;série des tests&lt;/strong&gt; pour chacune d&amp;rsquo;elles.&#xA;&lt;/div&gt;&#xA;&lt;!--&#xA;- Un corrigé se trouve à cette adresse&amp;nbsp;: &#xA;&lt;a class=&#34;remote&#34; href=&#34;#ZgotmplZ&#34; target=&#34;_blank&#34;&gt;&amp;lt;https://repl.it/join/azqimfmv-dlatreyte&amp;gt;&lt;/a&gt;&#xA;&#xA;&gt;&#xA;--&gt;&#xA;&lt;h2 id=&#34;recherche-séquentielle-ou-linéaire&#34;&gt;Recherche séquentielle (ou linéaire)&lt;/h2&gt;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  La &lt;strong&gt;recherche séquentielle (ou linéaire)&lt;/strong&gt;  consiste à&#xA;&lt;em&gt;comparer la valeur recherchée à toutes les valeurs présentes dans le tableau&lt;/em&gt;.&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;recherche-séquentielle-itérative&#34;&gt;Recherche séquentielle itérative&lt;/h3&gt;&#xA;&lt;div class=&#34;note normal&#34;&gt;&#xA;  &lt;h4 id=&#34;algorithme-1&#34;&gt;Algorithme 1&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;Fonction :&lt;/strong&gt; recherche(tab, valeur)&lt;br&gt;&#xA;&lt;strong&gt;Action :&lt;/strong&gt; recherche la valeur « valeur » dans le tableau « tab »&lt;br&gt;&#xA;&lt;strong&gt;Début&lt;/strong&gt;&lt;br&gt;&#xA;&lt;span style=&#34;margin-left: 2em&#34;&gt;i ⟵ 0  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 2em&#34;&gt;i_val ⟵ -1  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 2em&#34;&gt;nb ⟵ Longueur(tab)  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 2em&#34;&gt;&lt;strong&gt;TantQue&lt;/strong&gt; i &amp;lt; nb &lt;em&gt;Faire&lt;/em&gt;    &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 4em&#34;&gt;&lt;strong&gt;Si&lt;/strong&gt; tab[i] = valeur &lt;strong&gt;Alors&lt;/strong&gt;  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 6em&#34;&gt;i_val ⟵ i  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 4em&#34;&gt;&lt;strong&gt;FinSi&lt;/strong&gt;  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 4em&#34;&gt;i ⟵ i + 1  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 2em&#34;&gt;&lt;strong&gt;FinTantQue&lt;/strong&gt;  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;span style=&#34;margin-left: 2em&#34;&gt;&lt;strong&gt;Renvoyer&lt;/strong&gt; i_val  &lt;/span&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Fin&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>La récursivité appliquée aux chaînes de caractères et aux listes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-2-recursivite-chaines-listes/</link>
      <pubDate>Tue, 08 Sep 2020 04:53:31 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-2-recursivite-chaines-listes/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Une chaîne de caractère est une &lt;strong&gt;structure de données&lt;/strong&gt; qui permet de rassembler en un &lt;em&gt;unique objet&lt;/em&gt; une &lt;strong&gt;succession ordonnée&lt;/strong&gt; de caractères. Ainsi, une &lt;em&gt;définition récursive d&amp;rsquo;une chaîne de caractères&lt;/em&gt; pourrait être :&lt;/p&gt;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  &lt;h4 id=&#34;définition-récursive-dune-chaîne-de-caractères&#34;&gt;Définition récursive d&amp;rsquo;une chaîne de caractères&lt;/h4&gt;&#xA;&lt;p&gt;Une chaîne de caractères est :&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;soit la chaîne de caractères vide ;&lt;/li&gt;&#xA;&lt;li&gt;soit constituée de son premier caractère et du reste des caractères qui forment aussi une chaîne de caractères (éventuellement vide).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Une liste est une &lt;strong&gt;structure de données&lt;/strong&gt; qui permet de rassembler en un &lt;em&gt;unique objet&lt;/em&gt; une &lt;strong&gt;succession ordonnée&lt;/strong&gt; d&amp;rsquo;objets (ou de valeurs). Ainsi, une &lt;em&gt;définition récursive d&amp;rsquo;une liste&lt;/em&gt; pourrait être :&lt;/p&gt;</description>
    </item>
    <item>
      <title>Récursivité sur les entiers</title>
      <link>https://dlatreyte.github.io/terminales-nsi/recursivite/1-1-recursivite-sur-entiers/</link>
      <pubDate>Sat, 05 Sep 2020 18:34:00 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/recursivite/1-1-recursivite-sur-entiers/</guid>
      <description>&lt;center&gt;&#xA;&lt;h3&gt;To understand recursion, you must first understand recursion.&lt;/h3&gt;&#xA;&lt;/center&gt;&#xA;&lt;p&gt;La &lt;strong&gt;récurrence&lt;/strong&gt; est un &lt;em&gt;raisonnement mathématique&lt;/em&gt; courant et parmi les plus puissants pour démontrer des théorèmes ou construire des objets. Par exemple, on l&amp;rsquo;utilise dans un cours de mathématique de lycée pour montrer que :&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Pour tout entier $n \geqslant 0$, on a : $1 + 2 + 3 + \ldots + n = \dfrac{n(n+1)}{2}$ ;&lt;/li&gt;&#xA;&lt;li&gt;Un entier naturel n&amp;rsquo;est autre que 0 ou le successeur d&amp;rsquo;un entier naturel (0 est 0, 1 est le successeur de 0, 2 est le successeur de 1, &amp;hellip;).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;En programmation, on peut raisonner de façon identique, nous allons &lt;strong&gt;construire des fonctions et des structures de données (listes chaînées, arbres, etc.) à l&amp;rsquo;aide d&amp;rsquo;une hypothèse de récurrence et d&amp;rsquo;un point de départ&lt;/strong&gt;. &lt;strong&gt;Le déroulement de la récurrence sera quant à lui pris en charge par la machine&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
