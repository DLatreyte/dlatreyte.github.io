<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programmation Dynamique on Accueil</title>
    <link>https://dlatreyte.github.io/tags/programmation-dynamique/</link>
    <description>Recent content in Programmation Dynamique on Accueil</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <lastBuildDate>Sun, 29 Jan 2023 21:48:22 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/tags/programmation-dynamique/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Décomposition d&#39;un problème en sous-problèmes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/0-decomposition-pb/</link>
      <pubDate>Sun, 29 Jan 2023 21:48:22 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/diviser-pour-regner/0-decomposition-pb/</guid>
      <description>&lt;h2 id=&#34;principe&#34;&gt;Principe&lt;/h2&gt;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  &lt;ul&gt;&#xA;&lt;li&gt;On décompose le problème en sous-problèmes plus simples.&lt;/li&gt;&#xA;&lt;li&gt;On résout les sous-problèmes.&lt;/li&gt;&#xA;&lt;li&gt;On combine les sous-problèmes de façon à construire la solution du problème initial.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;indépendance-des-sous-problèmes&#34;&gt;Indépendance des sous-problèmes&lt;/h2&gt;&#xA;&lt;div class=&#34;note tip&#34;&gt;&#xA;  &lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;Si les sous-problèmes sont indépendants les uns des autres&lt;/em&gt; : &lt;strong&gt;« Diviser pour règner »&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;Si les sous-problèmes dépendent les uns des autres&lt;/em&gt; : &lt;strong&gt;« Programmation dynamique »&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Découpe d&#39;une corde</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/3-decoupe-corde/</link>
      <pubDate>Tue, 09 Mar 2021 10:20:05 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/3-decoupe-corde/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&#xA;&lt;a class=&#34;remote&#34; href=&#34;../../terminales-nsi/chap-14/chap-14-3/decoupe_corde_Q.pdf&#34; target=&#34;_blank&#34;&gt;Énoncé au format pdf&lt;/a&gt;&#xA;&#xA;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&#xA;&lt;a class=&#34;remote&#34; href=&#34;../../terminales-nsi/chap-14/chap-14-3/decoupe_corde_QR.pdf&#34; target=&#34;_blank&#34;&gt;Corrigé au format pdf&lt;/a&gt;&#xA;&#xA;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Problème du rendu de monnaie</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/2-rendu-monnaie/</link>
      <pubDate>Sun, 28 Feb 2021 05:28:54 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/2-rendu-monnaie/</guid>
      <description>&lt;h2 id=&#34;énoncé-du-problème&#34;&gt;Énoncé du problème&lt;/h2&gt;&#xA;&lt;p&gt;Un commerçant cherche à rendre la monnaie à ses clients &lt;strong&gt;de façon optimale&lt;/strong&gt;, c&amp;rsquo;est-à-dire avec le &lt;strong&gt;nombre minimal de pièces et de billets&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Dans ce problème,&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;On suppose que les clients ne donnent que des sommes entières en euros (pas de centimes pour simplifier) ;&lt;/li&gt;&#xA;&lt;li&gt;Les valeurs des pièces et billets à disposition sont : 1, 2, 5, 10, 20, 50, 100, 200 et 500. On suppose que l&amp;rsquo;on a autant d&amp;rsquo;exemplaires que nécessaire de chaque pièce et billet ;&lt;/li&gt;&#xA;&lt;li&gt;Dans la suite, afin de simplifier, on désigne par « pièces » à la fois les pièces et les billets.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;algorithme-glouton&#34;&gt;Algorithme glouton&lt;/h2&gt;&#xA;&lt;p&gt;Un client nous achète un objet qui coûte 53 euros. Il paye avec un billet de 200 euros. Il faut donc lui rendre 147 euros, par exemple un billet de 100, deux billets de 20, un billet de 5 et une pièce de 2.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Autour de la suite de Fibonacci</title>
      <link>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/1-suite-fibonacci/</link>
      <pubDate>Thu, 25 Feb 2021 04:49:20 +0400</pubDate>
      <guid>https://dlatreyte.github.io/terminales-nsi/programmation-dynamique/1-suite-fibonacci/</guid>
      <description>&lt;h2 id=&#34;rappel--récursivité-terminale&#34;&gt;Rappel : récursivité terminale&lt;/h2&gt;&#xA;&lt;p&gt;La définition de la fonction factorielle est&#xA;$$&#xA;n! =&#xA;\begin{cases}&#xA;1 &amp;amp; \text{if } n = 0 \cr&#xA;n \times (n-1)! &amp;amp; \text{sinon}&#xA;\end{cases}&#xA;$$&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Définir la fonction &lt;code&gt;fact_env&lt;/code&gt; qui calcule la factorielle d&amp;rsquo;un entier naturel $n$, &lt;em&gt;sans oublier le jeu de tests&lt;/em&gt;.&lt;br&gt;&#xA;La spécification de la fonction est :&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Retourne la factorielle de n.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Algorithme : récursivité enveloppée&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr /&gt;&#xA;&lt;details style=&#34;background-color: #f2f2f2;&#34;&gt;&#xA;    &lt;summary&gt;&#xA;        &lt;strong&gt; Réponse&lt;/strong&gt;&#xA;    &lt;/summary&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Retourne la factorielle de n.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Algorithme : récursivité enveloppée&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;120&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;assert&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fact_env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;40320&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;/details&gt;&#xA;&lt;hr /&gt;&#xA;&lt;div class=&#34;note normal&#34;&gt;&#xA;  &lt;p&gt;En informatique, la &lt;strong&gt;récursion terminale&lt;/strong&gt;, aussi appelée, récursion finale, est un &lt;em&gt;cas particulier de récursivité assimilée à une itération&lt;/em&gt;.&lt;br&gt;&#xA;Une fonction à récursivité terminale (dite tail-recursive en anglais) est une fonction où l&amp;rsquo;&lt;strong&gt;appel récursif est la dernière instruction à être évaluée&lt;/strong&gt;. Cette instruction est alors nécessairement « pure », c&amp;rsquo;est-à-dire qu&amp;rsquo;elle consiste en un simple appel à la fonction, et jamais à un calcul ou une composition.&lt;br&gt;&#xA;Les algorithmes récursifs exprimés à l&amp;rsquo;aide de fonctions à récursion terminale profitent donc d&amp;rsquo;une optimisation de la pile d&amp;rsquo;exécution.&lt;br&gt;&#xA;Cette réorganisation économise de l&amp;rsquo;espace mémoire car aucun état, sauf l&amp;rsquo;adresse de la fonction appelante, n&amp;rsquo;a besoin d&amp;rsquo;être sauvé sur la pile d&amp;rsquo;exécution. Cela signifie également que le programmeur n&amp;rsquo;a pas à craindre l&amp;rsquo;épuisement de l&amp;rsquo;espace de pile ou du tas pour des récursions très profondes.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
