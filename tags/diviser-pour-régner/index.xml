<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Diviser pour régner on Accueil</title>
    <link>https://dlatreyte.github.io/tags/diviser-pour-r%C3%A9gner/</link>
    <description>Recent content in Diviser pour régner on Accueil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <managingEditor>david.latreyte@louismassignon.com (David Latreyte)</managingEditor>
    <webMaster>david.latreyte@louismassignon.com (David Latreyte)</webMaster>
    <lastBuildDate>Sun, 29 Jan 2023 23:13:31 +0400</lastBuildDate>
    <atom:link href="https://dlatreyte.github.io/tags/diviser-pour-r%C3%A9gner/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Somme des $n$ nombres d&#39;un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/7-somme-nombres/</link>
      <pubDate>Sun, 29 Jan 2023 23:13:31 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/7-somme-nombres/</guid>
      <description>L’objectif de ce document est d’écrire et d’implémenter un algorithme s’appuyant sur le raisonnement « Diviser pour régner » qui permet de déterminer la somme des $n$ nombres (entiers) d&amp;rsquo;un tableau.
Écrire le code de fonction somme1 dont la spécification est : 1 2 3 4 5 6 7 def somme1(tab: List[float]) -&amp;gt; float: &amp;#34;&amp;#34;&amp;#34; Calcul de la somme des nombres éléments de tab. Algorithme : Récursivité enveloppée &amp;#34;&amp;#34;&amp;#34; Penser à écrire un jeu de tests.</description>
    </item>
    <item>
      <title>Diviser pour régner</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/0-diviser-pour-regner/</link>
      <pubDate>Sun, 29 Jan 2023 21:53:04 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/0-diviser-pour-regner/</guid>
      <description>Dans quel cas ? On parvient à découper un problème en sous-problèmes indépendants les uns des autres. On poursuit cette démarche jusqu&amp;rsquo;à aboutir à une situation simple : cas de base. La solution du cas de base est généralement simple à obtenir et permet la construction de la solution du problème. Remarque C&amp;rsquo;est l&amp;rsquo;indépendance des sous-problèmes qui permet la construction de la solution globale directe par recombinaison des solutions intermédiaires.</description>
    </item>
    <item>
      <title>Décomposition d&#39;un problème en sous-problèmes</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/0-decomposition-pb/</link>
      <pubDate>Sun, 29 Jan 2023 21:48:22 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/0-decomposition-pb/</guid>
      <description>Principe On décompose le problème en sous-problèmes plus simples. On résout les sous-problèmes. On combine les sous-problèmes de façon à construire la solution du problème initial. Indépendance des sous-problèmes Si les sous-problèmes sont indépendants les uns des autres : « Diviser pour règner ». Si les sous-problèmes dépendent les uns des autres : « Programmation dynamique ». </description>
    </item>
    <item>
      <title>Recherche des plus grand et petit éléments dans un tableau</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/2-minmax/</link>
      <pubDate>Wed, 26 Jan 2022 05:14:44 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/2-minmax/</guid>
      <description>L&amp;rsquo;objectif de ce document est d&amp;rsquo;écrire et d&amp;rsquo;implémenter un algorithme s&amp;rsquo;appuyant sur le raisonnement « Diviser pour régner » qui permet de déterminer le maximum et le minimum des éléments dans un tableau.
Générer une liste contenant un million de termes choisis aléatoirement entre un et mille milliards. Réponse 1 2 3 4 from random import randint if __name__ == &amp;#34;__main__&amp;#34;: tab = [randint(1, int(1e12)) for i in range(int(1e6))] Utiliser les fonctions min et max fournies par le langage Python afin d&amp;rsquo;afficher les maximum et minimum dans la liste.</description>
    </item>
    <item>
      <title>Les tours de Hanoï</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/3-tour-hanoi/</link>
      <pubDate>Tue, 24 Nov 2020 04:54:14 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/3-tour-hanoi/</guid>
      <description>Le problème mathématique des tours de Hanoï a été inventé par Édouard Lucas. Paru d&amp;rsquo;abord en fascicule en 1889 , il est publié ensuite dans le tome 3 de ses « Récréations mathématiques », parues à titre posthume en 1892. Il annonce que ce problème est dû à un de ses amis, N. Claus de Siam (anagramme de Lucas d&amp;rsquo;Amiens, Amiens étant sa ville de naissance), prétendument professeur au collège de Li-Sou-Stian (anagramme de Saint Louis, le lycée où Lucas enseignait).</description>
    </item>
    <item>
      <title>Rotation d&#39;une image bitmap d&#39;un quart de tour</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/6-rotation-image/</link>
      <pubDate>Wed, 18 Nov 2020 17:12:52 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/6-rotation-image/</guid>
      <description>L&amp;rsquo;objectif de cette activité est l&amp;rsquo;écriture d&amp;rsquo;une fonction qui effectue la rotation d&amp;rsquo;une image bitmap de 90 degrés en utilisant le principe « Diviser pour régner ».
On peut manipuler des images en Python à l&amp;rsquo;aide du module PIL (Python Image Library). Une première partie de l&amp;rsquo;activité est consacrée à la prise en main de ce module. Dans un second temps, la fonction de manipulation des bits est développée.
Images numériques Définition L&amp;rsquo;image matricielle Une image matricielle, ou « carte de points » (de l&amp;rsquo;anglais « bitmap »), est une image constituée d&amp;rsquo;une matrice de points colorés, c&amp;rsquo;est-à-dire, constituée d&amp;rsquo;un tableau, d&amp;rsquo;une grille, où chaque case possède une couleur qui lui est propre et est considérée comme un point.</description>
    </item>
    <item>
      <title>Le tri fusion</title>
      <link>https://dlatreyte.github.io/terminales-nsi/chap-10/1-tri-fusion/</link>
      <pubDate>Wed, 18 Nov 2020 17:12:24 +0400</pubDate><author>david.latreyte@louismassignon.com (David Latreyte)</author>
      <guid>https://dlatreyte.github.io/terminales-nsi/chap-10/1-tri-fusion/</guid>
      <description>Le tri fusion d&amp;rsquo;un tableau Description du tri Dans cette partie, nous allons essayer de comprendre les principes sur lesquels s&amp;rsquo;appuie ce tri. Son implémentation, pour des tableaux ou des listes chaînées, sera développée dans les prochaines sections.
Le tri fusion s&amp;rsquo;appuie sur la méthode Diviser pour régner pour trier les $n$ éléments d&amp;rsquo;une séquence $S$ :
Diviser : Si la séquence $S$ est composée de 0 ou un élément, retourner $S$ immédiatement ; cette séquence est déjà triée.</description>
    </item>
  </channel>
</rss>
